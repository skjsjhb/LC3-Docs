# 0-4 Java 基础知识

在接下来的四节，我会为你铺垫一些插件开发中用到的 Java 编程知识。可能有些长，也可能有些枯燥乏味，但我会尽量让它变得简单而快乐一些。

## 我们从一个数字开始

```java
1
```

这是个数字 1，很小巧，对吧？即使不需要任何编程知识，你也能读懂它的含义。

这个数字 `1` 代表的就是 1，是它的**字面含义**，因此，像这样**直接写出来**的，“**一看就知道**”是什么东西的，在 Java 中被称作**字面量（Literal）**。

---

还有一些其它类型的字面量：

```java
true
false
```

`true` 代表“真的”或者“对的”，`false` 代表“假的”或者“错的”，它们两个是天生的一对，合称**布尔值（Boolean Value）**，又名**逻辑值**。

数字有 0、1、2……等等，但是逻辑值**只有两个**：不是 `true` 就是 `false`，没有其它可能。

```java
-32768
114.514
```

在数字中，负号和小数点可以正常使用，就像数学中一样。

```java
"这是一个字符串，但是锟斤拷烫烫烫"
"Ciallo～(∠・ω< )⌒☆"
```

用双引号（`""`）**加在一些文字的两端**，就把它变成一个**字符串（String）**。虽然术语很难懂，但**字符串其实就是文字**，只不过是，可以被程序处理的文字。

> Kirara：为什么要加引号呢？

我们来举个例子说明一下：

> **你的地址**
> 
> 如果我想知道 Kirara 的家在哪里，我会告诉她：“请写下你的地址”。
> 
> 你肯定不会这么写：
> 
> ```
> 你的地址
> ```
> 
> （不过，Kirara 可能会这么干，这小丫头比较调皮……）
> 
> 而是
> 
> ```
> 樱云岛 光点郡 花海塔 风月街 21 号
> ```
> 
> 她**解读**了我所说的“你的地址”的意思，并把它**换成了**自己的真正住址。这也是 Java 解读你的代码时的一般情况。
> 
> 但是，如果我就是想让她**写出“你的地址”这四个字**怎么办？我不能再提出同样的请求，因为她还是会尝试解读这个词的意思，我也不能指望她一时抖机灵，因为 Java 可不会抖机灵。
> 
> 这个时候，我们通常会说：“请写下‘你的地址’这四个字。”看到这里的**单引号**了吗？这是为了告诉听到这句话的人：**请把“你的地址”四个字按原样写出来，不要解释**。
> 
> 在 Java 中，想做类似的事情也是一样的，要想写任意的字符串而不需要 Java 解读，就需要加上引号。

当你用 Word 之类的软件写文字的时候，你是在**写作**，文章的内容你可以任意发挥，因为 Word **不会尝试解读你的文章**。但是 Java 不一样，在开发软件的时候，我们是在**编码**，而编码是有**很固定的语法**的，如果你瞎写乱画，Java 就不给你干。

所以，如果我们想让 Java 处理一些任意文字（比如 `"Ciallo～(∠・ω< )⌒☆"`），却又**不想让它觉得我们是在瞎写乱画**，就要在两边**加上引号**，告诉 Java：“**你就把这些原样记住，别管我什么意思**”，使得 Java 不要把它**当作代码**，而是**当作普普通通的文字**。

例如，`123` 是一个数字，读作“一百二十三”，但 `"123"` 却是一个字符串，读作“一二三”。为什么是这样呢？我们刚才说过，不带引号的 `123` **很特殊**，Java 会把它当作数字来对待，而在两边**加上引号** `""` 后，它就变得**没那么特殊**了，Java 会把它看作普普通通的文字，也就是**字符串**啦。

?> 软件工程师们通常喜欢用 `"blahblah"` 这样两边带引号的写法来表示他们所说的是个字符串，虽然去掉引号也完全没有问题，不过这可能是为了彰显他们对于代码语法的深入理解。你只需要知道，两端的引号是用来**标记**字符串的，却**不是字符串内容的一部分**。

---

当然，只能写一些字面量是没什么意思的，1 就是 1，2 就是 2，哪怕是复杂如 `"Ciallo～(∠・ω< )⌒☆"` 这样带特殊符号的字符串，也不过就是一些字。它们虽然在这里，却做不了什么事情。**1 不会自动和 2 加起来变成 3，而字符串也不会自己显示在屏幕上**，这可没什么意思。

## 连词成句

事情是从这里开始变得好玩的。

```java
1 + 1
```

你几乎要脱口而出 `2`，不过现在暂且把它理解为将两个数相加。很显然，这里的 `+` 符号有加法的意思，它是一个**运算符（Operator）**，这你在数学中已经学过。不过，这里还有一个更重要的概念：

**`1 + 1` 是一个整体，它的值是 2。**

这个由值和运算符构成的“整体”，学名为**表达式（Expression）**。

> **到底怎么回事？**
> 
> 表达式可以看成是“**还没有算出结果的算式**”，它把“要做什么”写了出来，而不是直接写出结果。在小学数学中我们就知道，每一个算式都有一个**结果**，所以当 Java 看到一条表达式的时候，它就会**计算出来它的结果**，即所谓的**值（Value）**。紧接着，它把**整个表达式换成这个结果**，然后继续下一步。所以像是 `1 + (1 + 2)` 这样的表达式，是先变成 `1 + 3` 再变成 `4` 的。请体会一下这个过程。
> 
> 既然如此，你可能会有疑问：“直接算出来不就好了么？”但是，表达式里面可能含有未知数，也就是**变量**，这些没办法在写程序的时候就猜出来。
> 
> 另外，**单一的字面量也可以看作表达式**，比如 `2`，虽然它没有什么要计算的，但是它的结果确实是 `2`，不是吗？

相比一个字面量 `2`，一个表达式能做的事情**更多**：它虽然也代表 2，但是它很清楚地**表达**了一个操作：把两个 `1` **加起来**。产生结果 `2` 并不是它的目的，它的目的是要告诉 Java：**你得做点什么，把两个数相加！**

这几乎可以说是你的第一个程序 —— 它**告诉计算机要做点什么**。

计算机能够**计算**表达式的**值（Value）**：`1 + 1` 计算出来的值是 `2`，而 `30 * 30` 计算出来的值是 `900`。工程师们把这个计算过程称为**求值（Evaluate）**。

---

这里还有一些表达式：

```java
3.1416 * (7 * 7 - 5 * 5) * (4 + (1 + 2))
```

括号的运算规律和数学中相同，不过只能使用小括号，多层括号只需要一层层嵌套起来，Java 能分辨哪个是哪个。

```java
"Cia" + "llo~"
```

等一下，字符串是怎么“相加”的？实际上，`+` 不仅有数学上的加法含义，它还能用来将两个字符串“**粘贴**”在一起。这个表达式的值是将两个长度分别为 3 和 4 的字符串**拼接（Concatenate）**，得到一个长为 7 的字符串 `"Ciallo~"`。

```java
"我是 No." + 1
```

**字符串和数字**做加法……好吧，事实上，在 Java 里面这么写的时候，Java 会先把 `1` **转换为字符串** `"1"`，然后再进行拼接，得到 `"我是 No.1"`。

> Kirara：那为什么不是把字符串转换为数字，然后做加法呢？

—— 要不你试试，告诉我怎么把 `"锟斤拷烫烫烫"` 转换成对应的数字。

布尔运算比较特殊，我们稍后再提及。

## 给它取个名字！

你可以给表达式的值取一个名字。

```java
int a = 3 * 7;
```

`3 * 7 = 21`，所以上面这一行相当于给 `21` 取名为 `a`。以后用到 `a` 的地方，Java 就会认为它是 `21`。

这个操作的术语叫做**定义（Define）**，你定义了一个新的变量，名字叫做 `a`，它的值是 `21`。你也可以说是“创建”了一个变量，“新增”了一个变量……都没问题。

开头的 `int` 是什么呢？这是变量的**类型**。为什么要有类型呢？因为，即使复杂如 `2147483647 * 114514 + 1919810` 这样的表达式，你也可以**一眼看出来它不过是数学运算**，然而，如果把这种东西摆在你面前：

```java
a + c
```

即使是这么简单的东西，也**没人知道**这到底是什么玩意。`a` 和 `c` 都是数字，进行加法，还是字符串，进行拼接？谁也不知道。

为了解决这一问题，就需要对于变量定义**类型（Type）**。`int` 代表**整数（Integer）**，这意味着 `a` 在将来使用的时候，只能代表整数，同时也告诉所有阅读这段代码的人：**变量 `a` 是个整数**。

> **到底怎么回事？**
> 
> 你会注意到我一直在说**取名**这个词，实际上，如果用数学中**未知数**的概念来理解，我们也可以说“`a` 的值是 `21`”，或者干脆 “`a` 等于 `21`”。这么说虽然没有什么本质性的问题，而且有助于理解，但变量在 Java 中的工作原理，其实并不完全是这样……这个问题我们稍后还会讨论。

常用的基本类型还有：

- `double` 和 `float`：小数（稍后介绍区别）

- `String`：字符串

- `boolean`：逻辑值（`true` 和 `false`）

*当然 `String` 其实不是一个基本类型，只是现在先这么说，稍后再介绍有关引用类型的内容。*

---

所以 Kirara 就写出这样的代码：

```java
double a = 114.514;
String a = "blahblah";
boolean a = false;
```

呃，有些不对。**变量只能定义一次**，像 Kirara 这样定义三个同名的变量，Java 是不干的，它觉得她违反了变量类型规则。

—— 为什么只能定义一次？试想如果现在突然出现一个和你同名同姓身份证号还一样的人，会发生什么？到底谁是谁啊，一定会引起大混乱的（笑）。

因此，我们需要取一些不一样的名字。

```java
double 1145 = 114.514;
String str = "blahblah";
boolean c = false;
```

呃，还是不对，原因主要是 `1145` 并不是一个**有效的变量名**（可真是麻烦！）。变量名有如下的要求：

- 只允许使用大小写英文字母，下划线 `_`，美元符 `$`和数字。

- 数字不可以在开头。（~~`1Password`~~ 不行）

- 不可以与关键字重复。（~~`int`~~ 不行，但是 `int1` 可以）

> **你是职业选手吗？**
> 
> 其实变量名可以用包括中文在内的很多特殊符号，但我这辈子都不想再见到 `pei置` 这种要人命的变量名了。不管 Java 规范是不是认为这东西有效，在我们的 Code Style 这里这就是**无效**。

---

变量可以在创建后再修改：

```java
int a = 5;
a = 10;
```

自第二行之后 `a` 的值就是 `10` 了。

在这里，你不能再写一个 `int a = 10;`，因为这样写就代表你想**再创建一个新的变量**，但是 `a` 这个名字，已经用掉了。

**要使用（包括修改）一个已有的变量，只需要直接使用它的名字。**

让我们把这些结合在一起！

```java
String a = "3x7=";
int b = 3;
int c = 7;
int d = b * c;
String f = a + d;
```

这时，`f` 的值是字符串 `"3x7=21"`。

## 文不加“点”

当使用的表达式变得复杂起来之后，写出来可能就像是这样：

```java
int result = ((((2 + 3) * (((10 - 5) / (7 * 2))) + ((4 % 3) * 2) - (8 / 2))) * ((5 + 6) / (9 - 2))) / (1 + (2 * 3) - (4 / (5 % 6) + (7 / 8))))
```

简直要吓死人，这就像**说话不打句号**一样，所有的话放在一句话里面来说。

这种情况，就是把复杂的表达式写在了一句话中，术语称为**语句（Sentence）**。

一条语句相当于口语中的“一句话”，我们指挥别人做事也是“做这个，做那个”……是一条一条的指令执行，在 Java 中就是多条语句。

下面是**三条**语句：

```java
int a = 1;
int b = a + 1;
String c = "str";
```

你会发现，每一条语句都以 `;` 结尾，这很像中英文中的句号，代表一句话的结束。

**分号代表一条语句的结束。**

多条语句可以写在同一行中，一条语句也可以拆到多行之中 —— 只要它其中没有分号，Java 就会将它解释为一个整体。

```java
String a = "这段话太长，所以我把它" +
           "拆成两行来写。";

String b = "这两条语句"; String c = "可以写在同一行";
```

---

语句是程序执行的基本单元，Java 在执行你的语句的时候，总是一条一条语句执行的。

**不形成语句的东西，是没办法被执行的。**

现在这里有一段被剪掉了一半的代码：

```java
int a = 2 +
```

这就不能成为一条语句。Java 知道你的意思是**给 `a` 赋值**，也知道 `a` 的值是 `2` 加上什么东西，但是**到底加什么**？空格？上一行的变量？还是硬盘里面某个传统而古老路径的一张图片？**仅凭已有的信息，不足以知道程序的目的**，所以 Java 会**继续向后读**，直到找到一条**完整的语句**。

我们把剪掉的后半段放回来：

```java
2 +
3;
```

Java 读到第二行的时候，终于发现了加法 `+` 的另一个被加数，同时也看到它心心念念的分号 `;`（代表语句的结束），现在它终于明白，我们要计算的是 `2 + 3`，它算出来 `5`，然后将它赋给 `a`。

所以现在，我们得到一个很重要的结论：

**如果我们想让 Java 做什么，我们需要写出一些语句，来让 Java 执行。**

## 做点修改

刚才我们提到了可以给表达式一个名字，叫做**变量**：

```java
int a = 3 * 7;
```

你已经知道，变量之所以被叫做变量，是因为它们是**可变的**，你可以把一个变量的值**修改成另一个**，比如：

```java
int a = 3 * 7;
a = 4;
```

在第一行我们让 `a` 等于 `21`，紧接着在第二行，我们就把 `a` 的值**更改**为了 `4`（把 `4` 取名为 `a`）。

这就是对 `a` 进行**赋值（Assign）**，我们会说，把 `a` “赋值为” `4`，或者，把 `4` “赋给” `a`。

---

既然我们可以修改变量的值，我们就可以来做一些好玩的事情了！

```java
int a = 1;
a = a + 1;
```

你几乎又要脱口而出“无解！”，对吧？但是等一下，这可不是什么方程，`a = a + 1` 的意思是：**把 `a` 赋值为 `a + 1`。** `a + 1` 是什么？`2`。所以，`a` 现在是 2。

你可以发现，像是这样的赋值操作是**有方向**的 —— 从右往左，如果写成 `a <- a + 1`，就容易理解多了，可惜，Java 不允许这么写。

Java 在进行这样的**赋值**运算时，总是先计算等号右边的**表达式**（还记得吗，表达式可以计算出一个值），再把等号左边的变量**修改成**这个计算出来的值。表达式中如果含有变量，会把变量**代换成它现在的值**。简而言之：

**赋值，是把等号左边变量的值，改成等号右边表达式的值。**

## 稍后再用

假设我们要施展一种非常复杂的“魔法”来对变量 `a` 进行一些修改：

```java
int a = 5;

a = a + 1
a = a * 2;
a = a * a + 9;

a = a + 1;
a = a * 2;
a = a * a + 9;

a = a + 1;
a = a * 2;
a = a * a + 9;
```

如果这样的操作出现了不止一次，像上面这样**复制粘贴**代码很快就会让程序变得**像学术垃圾一样** —— 又长又枯燥无味，而且听君一席话如听一席话。

我们可以使用一种**特殊的结构**来把一些语句**打包**起来。下面的程序和上面的作用完全相同：

```java
int a = 5;

void hello() {
    a = a + 1;
    a = a * 2;
    a = a * a + 9;
}

hello();
hello();
hello();
```

*请先忽略多出来的诸如 `void` 这样的生词和额外的括号及空格。*

原本我们是把 `a = a + 1 ... + 9` **这几行**写三遍，而现在我们只需要**事先将它写一遍**，用一对括号 `{}` 把它们**打包**起来，然后像变量一样给它**取个名字**（这里是 `hello`），之后只需要**使用**它三遍就行了。是不是很像数学定理？只需要先证明一遍，就可以在各种地方**重复使用**，而不需要每次都从上下五千年再说起。

像这样**将一些语句打包起来，可以重复使用的结构**，就叫做**方法（Method）**，也称**函数（Function）**。大括号 `{}` 内部是被方法“打包”起来的语句，叫做**方法体（Method Body）**，从左括号 `{` 开始，到右括号 `}` 结束。

> **你是职业选手吗？**
> 
> 许多工程师认为，使用**函数**一词在 Java 中是不规范的，原因是 Java 作为严格面向对象的语言，适用于对象的**方法**一词比函数式编程的**函数**一词更能体现 Java 的特性。不过据我所查找到的资料来看，混用这两个词的人不少，其中甚至不乏许多高级工程师，本着方便起见的考量，本书中也就不做严格区分。

打包语句成为方法的操作叫做**定义**方法，也可以说是**创建**方法。使用已经定义好的方法，叫做**调用**方法。

?> 请注意，在**定义方法**的时候，方法体是**不执行**的。也就是说，`void hello() {}` 的大括号 `{}` 中的三条语句不会立刻执行，而是直到下面**调用**的时候才会执行。`a` 的值直到最后三行之前，都不会发生变化。就像设计师**画蓝图**一样，画蓝图的时候并不是**一边画一边搬砖盖房子**，而是画完之后，**有需要时再使用**蓝图来盖房子。

---

下面我们先介绍方法的**调用**，请看这一行：

```java
hello();
```

这句话的意思就是告诉 Java：**我要使用方法 `hello` 了，请准备一下！**

`hello` 是**方法名**，是你打包了语句之后给它取的名字。就像使用变量需要用变量名一样，调用方法也需要**提供方法的名字**。

方法名后有一对小括号 `()`，这可不是为了显得可爱（虽然确实有这个作用），这表示“**使用**”，也就是说，只要写出了方法名，然后在后面**加上**一对小括号 `()`，就自动构成一个**方法调用**。换而言之，**Java 一旦看到小括号 `()`，就会在这里开始执行 `hello` 方法中的内容**。

知道了这些，你就可以试试下面的练习：

```java
int a = 1;

void hello() {
    a = a + 1;
    a = a * 2;
    a = a * a + 9;
}

a = a - 1;
hello();
a = a - 12;
hello();
int b = a;
```

请问 `b` 的值是多少？或者说，`a` 最终的值是多少？请自己先做一下。

---

好吧，我知道有人想要直接看答案，答案写在下面的“到底怎么回事”里了。

> **到底怎么回事？**
> 
> 我们像 Java 一样，一行一行分析：
> 
> 1. `a` 最开始被创建的时候是 `1`。
> 
> 2. 看到了 `void hello() {`，这是**定义方法**，所以我们先跳过这一行和接下来的四行，等会再回来。（别忘了方法在**定义**的时候是**不执行**的 —— 设计师亲自搬砖吗？）
> 
> 3. 下面一行，`a` 被赋值为 `a - 1`，变成 `0`。
> 
> 4. 出现了 `hello()`，这是**调用方法**，所以现在我们**来到 `hello` 方法定义的开头**（`a = a + 1`）：
>    
>    - `a` 被加一变成 `1`。
>    
>    - `a` 被乘二变成 `2`。
>    
>    - `a` 被赋值为 `a * a + 9`，即 `2 * 2 + 9`，也就是 `13`。
>    
>    - 看到了右括号 `}`，方法结束，我们**回到刚才的位置**（`a = a - 12` 之前）。
> 
> 5. `a` 被减去 `12` 变成 `1`。
> 
> 6. 下一行又是一个 `hello()`，再来，我们再次来到 `hello` 方法定义的开头：
>    
>    - `a` 被加一变成 `2`。
>    
>    - `a` 被乘二变成 `4`。
>    
>    - `a` 被赋值为 `a * a + 9`，即 `4 * 4 + 9`，也就是 `25`。
>    
>    - 看到了右括号 `}`，方法结束，我们回到刚才的位置（`int b = a` 之前）。
> 
> 7. `int b = a;`，`a` 现在是 `25`，所以答案是 `25`。做对了吗？

---

现在你已经会使用方法了，那么，是时候看看怎么定义（创建）一个方法了：

```java
void hello() {
    a = a + 1;
    a = a * 2;
    a = a * a + 9;   
}
```

先忽略第一个 `void`，我们看到 `hello()`，这**很像**方法调用，但是由于它后面有一个 `{`，所以这**不是**方法调用，而是方法**定义**。

写在小括号前的 `hello` 是方法的**名字**，大括号 `{}` 中的内容是方法包含的要执行的语句。除此之外，还有一对小括号 `()`。为什么需要一对小括号呢？你已经知道，变量的定义是这样的：

```java
int a = 1;
```

如果方法定义不加这对括号 `()` 的话，就不方便区分到底**是方法还是变量**了 —— 它们可是两个完全不同的东西！在名字后面加上 `()`，就可以告诉 Java：“**我们不是在定义变量，而是在定义方法。**”

总结一下，我们只需要把要重复利用的语句**用 `{}` 打包**起来，在**前面加上**方法名和一对小括号 `()`，再在**最前面**添上一个神秘的 `void`，就可以**定义一个方法**以供日后使用。

?> 方法名的限制和变量名一样：大小写字母和数字，但不能以数字开头，不能包含除下划线 `_` 和美元符 `$` 之外的特殊字符，也不能与已有的关键字重复。当然了，即使一个是方法，一个是变量，也**不能**在同一个程序中用一样的名字，不然要引起大混乱的。

下面还有一个例子：

```java
String a = "丁真";
String b = "skjsjhb";

void foo() {
    a = "你好，我是" + a;
}

void bar() {
    b = "你好，我是" + b;
}
```

这里**定义**了两个方法（但是没有调用！所以，`a` 和 `b` 的值暂且还保持不变），一个在 `a` 前面加上 `"你好，我是"`，另一个在 `b` 前面加上同样的内容。

如果把它们分别**调用**一下：

```java
foo();
bar();
```

在这两行执行之后，`a` 变成 `"你好，我是丁真"`，而 `b` 变成 `"你好，我是 skjsjhb"`。

不过，这样好麻烦啊，明明都是在前面加上**同样的**内容，做的事情**这么相似**，只因**使用的变量不同**，就要定义**两个不同**的方法，很不公平。如果是有 1000 个变量，岂不是要**定义 1000 个**不同的方法？我们本来是想要**避免**学术垃圾那样的**复制粘贴**，结果到头来，除了那点不同之外，不**还是复制粘贴**吗？方法如果只能做这些，那也太没用了！

有没有一种办法，可以在**定义方法的时候不指定**用哪些变量，而在**调用方法的时候再决定**用哪个呢？设计 Java 的人已经考虑到了这个问题，我们在下下一节中介绍。

## 说人话！

在继续有关方法的复杂内容之前，我们先来讲点轻松的。

我特别喜欢英文中的一句话，现在分享给大家：

> People talking without speaking. People hearing without listening.

翻译成古汉语就是：

> 道而不述，闻而不名。

或者，不那么文雅地说大白话：

> 说了跟没说一样，听到了装没听到。‘

你知道，Java 会一板一眼地严格执行你的代码，不论你写什么它都会听。如果我们想写一些**给人类阅读，而不是给 Java 执行**的内容呢？这就是所谓**注释**。

```java
int a = 1;
// 这是注释，Java 不会执行
// 即使这一行写了 a = 2
// a 也不会变成 2
a = 2;
// 现在 a 变成 2 了
```

如果有一行中含有**行内注释符号** `//`，那么，从 `//` 开始，**包括它本身**，直至**这一行结束**，其中的内容都会被 Java 忽略。Java 既不会尝试解读，也不会试图把它保存下来，就好像这些文字从来不存在一样。

> Saki：我认为字符串应该也可以做到相同的事情？Java 同样也不会解读 `""` 中的内容，的说？

这么说是有些道理，不过**字符串**和**注释**还是有些区别，请看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 尽管 Java 不会尝试解读字符串中的内容，但它会把它**记忆下来**，作为一种字面量，字符串可以被赋值给变量：
> 
> ```java
> String s = "这是一个字符串，不会被解读";
> ```
> 
> 尽管 Java 不理解引号里的意思，但它还是尽职尽责地将它记录下来，然后将 `s` 的值设置为它。然而，对于注释则是完全不一样的。注释会在 Java 执行代码的时候被当作空气，所以像这样的代码：
> 
> ```java
> String s = // 这是注释，它不会被处理
> ```
> 
> 这行代码实际上是**错的**……因为，赋值运算符 `=` **两边都需要有东西**，注释会被 Java 直接**抹掉**，所以 `=` 的右边**什么也没有**，Java 不知道怎么修改 `s` 的值。如果是你，你知道吗？

---

注释能够让工程师在代码里面**插入一些人类的语言**，对程序进行一些**解释**，使得程序更易读。我们之前提到过，代码有很严格的格式规范，即使是用来解释代码的文字也会被 Java 认为是“瞎写乱画”，所以我们需要使用注释来告诉 Java：“这是**说的人话**，可不要看哦。”

## 选择合约

在我们介绍有关方法的进一步内容之前，先让我讲一个故事。

> **猫猫刺客 Neko**
> 
> Neko 曾经是 Saki 的一位好朋友，她们不仅是业务上的同事，更是生死之交 —— 在 Saki 成为一名游戏设计师之前，她是一位侦探。而她的同事 Neko，则是**职业杀手**。她活跃于光环郡的飞雪防御塔附近，猎杀着雇主指定的目标。
> 
> 所有和 Neko 进行过交易的人，都明白这当中的规矩：**只需要用一张纸条，上面写上仇敌的名字**，用它裹住一块小奶酪，在月圆的前一个晚上，挂在落雪之森从北向南数第六颗树的树枝上，你的仇敌就会在几天内由于“意外事件”消失不见：被独角兽刺穿喉咙，失足坠落，以及破伤风感染，等等。在此之后，一个用他们的心脏制成的灵球会悄悄出现在你的窗台上，**作为“任务完成”的提醒**。
> 
> 虽然没人曾从她口中打听到，但理事厅的长老们都一致认为，Neko **才不关心那个名字是什么意思**，她只是默默收下任务命令和报酬，然后，动手。
> 
> 无论是强大无比的防御塔还是尽职尽责的守卫，都拦不住 Neko 刺出的利爪。飞雪塔因此成为樱云岛上最和平的地方 —— 一开始，人们相互之间总是毕恭毕敬，生怕得罪了什么人而招来杀身之祸。而时间久了之后，这也就从压力下的作态变成了真情实感。
> 
> 啊啊，和平不来自花朵，而是来自剑锋啊。

好吧，这故事有点可怕也有点悲惨，不过现在，请回到现实中来。

还记得之前我们提出的问题吗？要怎么在**使用**方法的时候再决定用哪个变量呢？

嗯，其实没有什么魔法，我们原本的方法是这样的：

```java
void hello() {
    // 做点什么
}
```

如果我们想要让方法**从外界获取**一些变量的信息，我们就**把它写在小括号** `()` 里：

```java
void hello(int a) {
    // 做点什么
}
```

如果想要使用**不止一个**变量，还可以把多个变量**用逗号 `,` 分隔**开：

```java
void hello(int a, boolean b, String c, int d) {
    // 做点什么
}
```

这些变量是**从外界获取**的，也就是说，方法在定义的时候，本身并不决定 `a`、`b`、`c` 和 `d` 的值，它们的值是在**调用**的时候由**调用方法的语句**来提供的。

这些变量是发送给方法“**参考**”的值，所以它们叫做“用来参考的数据”，简称**参数（Argument 或 Parameter）**。请记住这条规则：

**参数以逗号 `,` 分隔，并写在方法后的小括号 `()` 里。**

参数的作用是提供给方法用作参考，我们不必为了计算 `a` 设计一个方法，计算 `b` 又设计另一个方法……只需要设计**一个**方法，然后在**调用**的时候，通过**参数**告诉方法，该使用哪个变量。Neko 并不是**生来（定义时）就知道**要干掉谁，是有人在**签订合约（调用）的时候**，**告诉她**仇敌的名字（参数），她才能够动手。

---

怎么样给方法提供参数呢？请看下面的例子。

```java
void hello(int a, int b) {
    int c = a + b;
}

hello(1, 2);
```

我们说过，参数是在**调用**的时候，给方法**用作参考**的。所以，要给方法提供参数，需要先写出**调用**方法的代码：**方法名，加上一对小括号** `()`。（最后再添上一个分号 `;` 来构成一条完整的语句）

```java
hello();
```

接着，我们把参数**对号入座**地放进小括号里：

```java
hello(1, 2);
```

这样，在这一次调用 `hello` 的时候，在方法的内部，`a` 就被 Java 自动赋值为 `1`，`b` 被赋值为 `2`。

> **到底怎么回事？**
> 
> 你应该已经发现了，当**定义**方法的时候，我们把形似变量的**参数**放在小括号 `()` 里，这些变量没有赋值，它们的作用仅仅是**占个位置**，等待着被填入实际的值。
> 
> 当**调用**方法的时候，我们把**实际的**参数值**对号入座**，从而给这些变量完成“赋值”。
> 
> 每一次调用的时候都可以**提供不同的参数**，方法可以**参考**这些不同的参数，**决定**自己要做什么。

现在我们写出这样的代码：

```java
void hello(int a, int b) {
    int c = a + b;
}

hello(1, 2);
hello(3, 4);
```

第一次调用方法的时候（`hello(1, 2)`），我们**提供的参数**是 `1` 和 `2`，于是，在 Java 计算 `a + b` 的值的时候，它把 `a` 换成对应的 `1`，`b` 换成 `2`，计算 `1 + 2` 得到 `3`。

第二次调用方法的时候，事情如出一辙，唯一的不同是**参数变成了** `3` 和 `4`，于是 Java 计算 `3 + 4` 得到 `7`。

发现了吗？不管参数**怎么变**，`hello` 做的事情就是简单把两个数**相加**。我们**不需要**为了计算 `1 + 2` **定义一个**方法，又为了计算 `3 + 4` **再定义一个**方法……只需要**创建唯一一个带参数的方法**，然后在**每次调用**的时候**提供**我们这次想让它计算的**参数**就行了。

对了，虽然这里我们使用了 `3`、`4` 这样的字面量，但不代表方法的参数就**只能**使用字面量（那还是很没用啊），方法的参数可以是任意的表达式，所以你也可以写：

```java
hello(1, 1 + 1);

int x = 2;
hello(1, x);

int y = 1 + 2;
hello(y, y + 1);
```

> Kirara：算出来的 `3` 还有 `7` 去哪里了呢？

我们之前提到过，表达式

```java
3 + 4;
```

虽然加了分号变成一条**语句**，可以单独执行，但 `3 + 4` 既没有**被赋值**给某个变量，也没有**参与其它表达式的计算**，也没有**被用作方法的参数**，所以，Java 辛辛苦苦**算完**这个表达式之后，发现它没有被用到，只好伤心地将它**丢掉了**。

这可不行啊，好不容易做出来的东西，如果没办法**返回**给**调用方法**的地方，那不就是白做了吗？就连 Neko 也知道要把灵球放在雇主的窗台上来告诉他们“**任务完成**”，如果 Java 的方法做不到，可就太没用了。

下一节我们解决这个问题。

## 合约完成

上一节里，我们的 `hello` 方法虽然可以计算参数 `a` 和 `b` 相加的结果，但是这个结果被简单丢掉了：

```java
void hello(int a, int b) {
    int c = a + b; // a + b 计算了，但没被用上（
}
```

虽然定义了变量 `c`，但是在后面的章节中我们会提到，这个 `c` 在 `hello` 方法外面是无法使用的。所以，尽管计算了 `a + b`，这个结果却没有被使用。

我们只需要稍加修改，就可以让这个结果**被利用**起来：

```java
int hello(int a, int b) {
    return a + b;
}
```

看看我们都改了些什么？

- 把此前以来一直神秘的 `void` **换成了** `int` —— “整数”。

- 在表达式 `a + b` 的前面**添加了**一个更神秘的 `return`。

这里要向大家说声对不起，虽然我们说，我们想**设法**回报算出来的结果，但是实际上，每个方法**生来**就可以做到这件事，而我们之前一直**忽略了**这一点，残忍地用 `void` 扼杀了它们的这个“天赋”。这个我们稍后提到。你现在只需要知道：

**在 Java 中，每个方法在设计的时候，都是“做点什么，然后回报点什么”。**

也就是说，每个方法**生来就包含**两样东西：**要做之事**，和要回报的**结果**。要做之事你已经知道，是写在大括号 `{}` 里的内容，叫做**方法体**。而至于要回报的**结果**，也就是**调用方法**之后要**返回**给调用方法的语句的**值**，叫做**返回值（Return Value）**。

**返回值是方法执行完成后，想要回报的数据**。谁调用了方法，它就返回给谁。

---

标记在**方法名**前面的，是 `void` 还有 `int` 这样的东西，你知道 `int` 代表“整数”，它是个**类型**。写在方法名前面的的类型，正是**方法返回值的类型**。

由于在定义方法的时候，返回值还**没有算出来**，因此它的**值**是**无法预测**的。不过，虽然**值**无法预测，但是它的**类型**却是可以预知的。就像**定义变量需要类型**（`int a = 1`）一样，定义方法的时候，也要说明**它的返回值是什么**。试想一下，如果 Neko 完成了刺杀任务，**不提前跟你打招呼**，就突然把血淋淋的心脏摆在你面前，你一定会吓一跳的。

我们还是拿 `hello` 举例子：

```java
int hello(int a, int b) {
    // 里面的东西省略...
}
```

这就告诉每一个使用 `hello` 方法的人：`hello` 执行完了后，会给你一个 `int` 类型的值。

> Kirara：它要怎么把这个值给我呢？直接塞进我的脑袋里吗？

约稿的时候怎不见你这么急……好吧，要回答这个问题，我们需要再看看**调用**方法的语句：

```java
hello(1, 2);
```

如果想要使用 `hello` 的返回值，可以这么写：

```java
int c = hello(1, 2);
```

我们知道 `hello` 返回 `int`，所以想把这个返回的数据赋值给变量，就也得给这个变量**相同的类型** `int`。

为什么我们可以这么做呢？请看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 形似 `hello(1, 2)` 的这个写法，除了执行方法里面的代码，它本身还是一个**表达式**。虽然长得不像算式，但你可以把 `hello(1, 2)` 看成是某种**魔法** —— **别管它算了些什么**，它最终总是能**得出一个结果**（表达式的**值**）。而实际上，这个结果就是 `hello` 的**返回值**。
> 
> 所以，**如果 `hello(1, 2)` 返回 `3` 的话**，在下面的代码中：
> 
> ```java
> int c = hello(1, 2) * 3;
> ```
> 
> 我们就可以**把 `hello(1, 2)` 换成** `3`，于是我们知道 `c` 最终等于 `9`。
> 
> 顺便提一句：为什么**定义**方法需要**指定返回值的类型**呢？这正是因为调用方法（像是 `hello(...)`）是一个**表达式**，**它的值**就是方法的**返回值**，而这个表达式可能参与其它表达式的运算，赋给某个变量，或者用作其它方法的参数。回忆一下还有什么能做这些事情：**字面量，变量，以及它们构成的表达式**。字面量写出来就知道是数字还是字符串，而变量也有类型定义，在这种情况下，如果返回值的类型不指定，就显得太不公平啦。

有一个特殊情况：如果返回值类型这里写了 `void`，代表“什么也没有”，也就是说这个方法**没有返回值**。由于 Java 的设想是每个方法**都要返回点什么**，但是有些方法确实按设计就**没有要返回的东西**，这种情况可以用 `void` 告诉 Java：“我**什么也不会给你**，别做梦了！”

如果一个方法什么也不返回，你就**不能把它当作一个表达式**，比如：

```java
int hello(int a) {
    // ...
}

void hello2(int b) {
    // ...
}

int c = hello(1) + 1;

int d = hello2();
```

这里的 `c` 可以被正常赋值：虽然我们不知道 `hello(1)` **具体是多少**，但我们知道它返回一个 `int`，而 `int` 可以和 `1` 相加再得到一个 `int`，我们把它赋给 `c`。

但是最后一行就出问题了：`hello2()` **什么也不返回**，所以等号 `=` 的右边相当于**什么也没有**……没什么东西可以赋值给 `d`，所以 Java 就要犯迷糊了。

所以，如果方法没有返回值，我们就只能把它单独丢在一边了：

```java
hello2();
```

---

现在我们知道方法名前面的 `void` 和 `int`（当然，还有其它类型）的意思了，那么，方法里面出现的 `return` 又是什么呢？

`return a + b;`  是**返回语句**，它代表：**我的返回值是** `a + b`。

我们已经在方法名的前面指定了方法的返回值**类型**，但类型毕竟只是个空壳，需要有一个实际的**值**来填满它。`return` 正是做这件事的：它把方法的返回值设置为它右边**表达式**的值。

下面还有一些 `return` 的例子：

```java
return a + b;
return (3 + 7) * 21;
return "Cia" + "llo" + "~";
```

Java 会先算出这些表达式的值，再把它们**返回**回去。

---

所以综合起来，**完整的**方法定义和调用看上去像是这样：

```java
int add(int a, int b) {
    return a + b;
}

int c = add(1, 2);
```

我们来捋一捋这一段代码的流程：

- `int add(int a, int b)` 这三行**定义**了一个方法 `add`：接受**两个参数**（都是 `int`），并且返回值的**类型**是 `int`。我们先跳过这三行（还记得吗，方法在定义时**不执行**）。

- 下一行是 `int c = add(1, 2)`，这是**赋值**，赋值是把等号 `=` 右边的值给左边的变量，右边的值是 `add(1, 2)`，这是**调用**方法 `add`：提供给它两个参数 `1` 和 `2`，并且期望从它那里得到一个值。
  
  - 由于要调用方法 `add`，因此我们现在**进入** `add` 里面，把**参数对号入座**，`a` 是 `1`，`b` 是 `2`。
  
  - 下一行是 `return a + b`，`return` **把返回值设成**它右边的值，它右边是 `a + b`，算出来是 `3`。
  
  - 方法到此结束了，于是我们带着刚刚算出来的返回值 `3`，回到原来的地方。

- 现在我们知道，`add(1, 2)` 这个**表达式**的结果是刚才的**返回值** `3`，把它换进去，就得到 `int c = 3`，于是我们知道 `c` 最终是 `3`。

把上面的案例稍微扩展一下，你就可以得到这样的结果：

```java
int d = add(add(1, 2), 3);
```

这里有两个 `add` 方法，第一个 `add` 方法的**两个参数分别是** `add(1, 2)` 和 `3`，而第二个的参数就是 `1` 和 `2`。

`add(1, 2)` 这么**大个的东西**放在参数上好像有点奇怪，不过我们已经知道它不过是个**表达式**，而方法的**参数可以是表达式**，这么一想，也挺合理的。

按照上面的流程分析，我们马上知道 `add(1, 2)` 的值是 `3`，把 `3` 换进去得到 `add(3, 3)`，它的值是 `6`，于是代码变成 `int d = 6`，所以 `d` 是 `6`。

再看一个：

```java
int e = 5;
e = add(e, e) * add(e, 1);
```

要注意一点，即使第二行要改变 `e` 的值，但直到右边的东西被算出来**之前**，`e` 的值都是**不变**的 —— 它还是 `5`，虽然只是，暂时的。

首先我们计算 `add(e, e)`，调用 `add` 方法，`a` 和 `b` 都代入 `e` 的值，也就是 `5`，所以表达式 `add(e, e)` 的值是 `10`。类似的，`add(e, 1)` 的值是 `6`。右边变成 `10 * 6` 就是 `60`，所以最终 `e` 被修改成 `60`。

## 恭喜……到目前为止。

从代码中的第一个数字开始，到表达式、变量、语句、方法和返回值，你已经历许多。这一节的内容很长，即使讲了一些故事，也难免枯燥。我在很多概念的解释上反复解释，花了很多笔墨，虽然不够简洁，但如果对于哪个概念不清楚的话，把我写的东西再仔细读一下，你应该能理解不少。

本节中所提到的内容，是后续用于构建包括类和对象在内更为复杂的系统所必需的，它们是组成庞大物件的微小原子，而即使是再为复杂的程序也是由基本的符号构成的。

Java 是一门很强大但学起来也不是那么简单的语言，虽然我尽可能压缩了用到的内容，省略了晦涩难懂的部分，但还是免不了长篇大论絮絮叨叨。如果你想找些额外的资料，这里有一些可以参考：

- [Java 教程](https://www.runoob.com/java/java-tutorial.html)，菜鸟教程出品的中文指南，有点老了但是很容易读。

- [Java Tutorial](https://www.w3schools.com/java/)，W3Schools 的英文教程，更全面但需要不错的英文水平。
