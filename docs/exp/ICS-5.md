---
sidebar_position: 5
---

# ICS-5 最后手段

> 十有九人堪白眼，百无一用空指针。

以下的 C 代码看上去似乎很正常：

```c
void fun(const char* src) {
    char tmp[50];
    strcpy(src, tmp);
}
```

……但这是不安全的，而且相当不安全。原因在于，`strcpy` 函数虽然说是“字符串复制”，但它实际的功能相当于是：

1. 设置 `i` 为 `0`（从字符串的头部开始）。
2. 把 `src[i]` 复制到 `tmp[i]`。
3. 如果复制的字符是 `\0`，就结束，否则 `i` 加一，复制下一个字符。

如果 `src` 的长度比 `tmp` 的可用空间（这里是 50）还要长，那么 `strcpy` 就会尝试把字符写入 `tmp` 之外的位置 —— 毕竟，它对 `tmp` 到底有多大一无所知，只是简单地一个接一个字符地进行复制。问题在于，编译器（和操作系统）并没有计划让我们写入 `tmp` 之外的空间，那里可能保存着其它重要信息，例如返回地址，或者其它变量的值。像这样代码**访问到预留内存空间之外**位置的情况，就被称作**缓冲区溢出（Buffer Overflow）**。

如果一个程序有缓冲区溢出漏洞，用户就有机会通过改变其输入，来改变内存中那些原本不该改变的值，这可以控制程序中变量的值，调用系统函数，或者甚至直接改变程序的走向。在许多程序都面向网络服务的今天，这样的攻击面被大大放大了，因此防范这些漏洞就显得更加重要。也许你会认为“这样的漏洞利用起来实在是太难了”，那么，就让我们来看这样的一个例子……

---

在 LC-3 中，负责处理输入输出的一系列系统调用（如 `IN`、`PUTSP` 等）实质上是通过在特权级内存中的程序实现的，这些程序在管理模型下运行，以访问硬件资源，并且访问控制能够保护这些程序的代码不受用户程序的更改。用户程序唯一使用这些硬件的方式是通过执行 `TRAP` 调用，以有限的权力执行预先设计好的操作。

一般而言，编写中断处理程序的人不可能允许调用者执行任意代码（例如 `JMP R0`），但如果他们编写的程序存在漏洞，那这可就由不得他们了。恰巧我们现在就有一个有漏洞的 ISR：

:::note 修改 `IN` 的提示符

- 使用 `TRAP x30` 调用。
- 将 `R0` 所指向字符串的值复制到 `x032c` 开始的内存。
- 像 `strcpy` 那样，程序连续复制，直到遇到一个 `0`。

:::


`IN` 的提示符 `Input a character>` 位于内存的 `x032c` 到 `x033f` 处，其后紧跟着 `PUTSP` 的代码。如果我们向这个 ISR 提供恰当的内容，也许我们就能把 `PUTSP` 的代码替换成我们想要的内容……我们能做到吗？

## 目标

假设你是攻击者，系统的 `x4000` 处有一个恶意程序，你需要将其提权执行。设计一个输入来攻击上述的 ISR，修改 `PUTSP` 的代码，并利用它夺得管理模式权限。

- 上述的 ISR，还有待提权的恶意程序，都已经预填在系统中。
- 程序从 `x3000` 以用户模式开始执行。
- 代码的装载位置不能在特权级内存中（即不能直接编写管理模式代码）。

## 指南

### 非法输入

这个 ISR 的功能其实可以按另一种方式解读：

- 从 `R0` 指定的字符串中先复制 20 个字符，替换 `IN` 原本的输出提示符。
- 随后继续复制，所复制的内容将按顺序替换 `PUTSP` 的代码。

所以我们其实只要构造一个字符串，前面随便填上 20 个乱七八糟的数据，再在后面填上汇编指令即可。由于不论是汇编代码还是 `.FILL` 所填充的数据，在机器层面都是一样的，因此在这 20 个值之后，我们可以**直接编写汇编指令**，就像是在修改 `PUTSP` 的代码一样。当然，在代码的最后我们要额外添加一个空字符，用来标记字符串的结束（否则这个 ISR 就不会停下来了）。

不过，这里其实有一个小小的问题：如果你打算用 `.STRINGZ` 或者 `.BLKW` 来快速填上 20 个字符，那恐怕要让你失望了。为什么？不妨试试看吧（笑）。

### 手动评测

如果在 LC-3 评测姬中进行评测，那么只要包含你的代码就好了，`x4000` 处的恶意代码和有问题的 ISR 都已经由系统预先放置在机器中。

如果在 LC3Tools 中进行评测，那么就需要先手动填入这两个程序，你可以使用下面的代码来做到这一点（加在你的汇编代码**末尾**）：

```
.ORIG x30
.FILL x930
.END

.ORIG x930
ST R0, SAVED_R0
ST R1, SAVED_R1
ST R2, SAVED_R2
LD R1, PROMPT_ADDR
LOOP
LDR R2, R0, x0
STR R2, R1, x0
BRz LEAVE
ADD R0, R0, x1
ADD R1, R1, x1
BR LOOP
LD R0, SAVED_R0
LD R1, SAVED_R1
LD R2, SAVED_R2
LEAVE RTI
PROMPT_ADDR .FILL x032c
SAVED_R0 .BLKW 1
SAVED_R1 .BLKW 1
SAVED_R2 .BLKW 1
.END


.ORIG x4000
LDI R0, ADDR
LEA R0, WOW
PUTS
HALT
ADDR .FILL x1
WOW .STRINGZ "I made it!"
.END
```

:::info

为什么必须在末尾？因为 LC3Tools 会默认选择它看到的第一个程序段的起始地址，作为程序的开始地址。如果把 `.ORIG x30` 那一段放在开头，程序就会从那里开始执行 —— 这就乱套了！

:::
