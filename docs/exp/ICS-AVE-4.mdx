# ICS-AVE-4 乐队急送

> Wake up. Wake up.

方正的中庭上竖起灯牌，钢琴、架子鼓和贝斯摆上舞台，期待已久的粉丝在场外排队等待……如果说联结是一支乐队梦想的开端，那么资金便是驱动梦想落地的燃料：演出虽然令人激动，但乐手也是要吃饭的。现在把时间前推几个月，我们故事的主人公 —— 家道中落的**小祥（T. Sakiko）** —— 正为乐队的重建添砖加瓦。在这个故事里，她选择了成为一名送货员，以筹措日益紧张的乐队资金。

和其它平台一样，小祥每多送出一单，她就能离目标更近一分。她配送的这个街区有着网格状的结构，每一个节点都以二维坐标 `(x, y)` 标识。在白天，所有道路对于电动车都是单行限行的：从位于 `(0, 0)` 的起点开始，只能向增加坐标值的方向移动，也就是说，送货状态的小祥可以从 `(0, 2)` 前往 `(1, 2)` 或者 `(0, 3)`，但不能反向而行。

由于电动车只能装下有限的物品，而我们的小祥已经急不可耐地想让乐队的大家一同登台演出，因此她设计了一套算法，用以确定每个节点 `(i, j)` 的优先级，算法的运行原理如下：

1. 计算到达该节点的最短距离：`S(i, j) = i + j`。
2. 计算到达该节点的路线数：`R(i, j) = R(i - 1, j) + R(i, j - 1)`，特别地，`R(i, 0) = R(0, j) = 1`。 
3. 最终的优先级：`P(i, j) = R(i, j) * 5 - S(i, j)`。

用高级语言来描述就是（这里使用 Go）：

```go
func priority(x, y int) int {
    return 5 * route(x, y) - step(x, y)
}

func route(x, y int) int {
    if x == 0 || y == 0 {
        return 1
    }

    return route(x - 1, y) + route(x, y - 1)
}

func step(x, y int) int {
    return x + y
}
```

## 演出计划

给定 `x` 和 `y`，按上述算法计算 `P(x, y)`。

- `x` 在 `x3100` 处。
- `y` 在 `x3101` 处。
- 结果应输出到 `x3200` 处。
- 必须使用递归的方式来解决本题。
- 运算中所涉及到的数据均保证在 LC-3 可接受的范围内。

## 曲谱速览

输入：

```
M[x3100] = x0001 (1)
M[x3101] = x0001 (1)
```

输出：

```
x0008 (8)
```

这是因为 `R(1, 1) = 2`，`S(1, 1) = 2`，于是 `P(1, 1) = 8`。

## 演奏技巧

### 如果不能记住这些的话……

这个问题的核心在于实现“调用自己”的功能。你或许会想，LC-3 已经有 `JSR` 了，只要在一段代码中，通过 `JSR` 跳转到自身……

```
FUNC

; 做点什么

JSR FUNC
RET
```

哦不，你不能。尽管这么做确实是“执行自己”，但构成一个程序的不是只有指令 —— 还有每条指令所依赖的**上下文（Context）**，也就是内存和寄存器的值。当程序从一次调用中返回时，我们希望所有的变量（在 LC-3 中就是寄存器）都**保持不变**。在高级语言中，这一点非常显然：

```go
func callMe(r1 int) {
    r1++

    fmt.Println(r1) // 这里输出 R1 的值
    callMe(r1)
    fmt.Println(r1) // 输出应该一致，即 R1 的值在调用 callMe 后不发生变化
}
```

高级语言拥有**作用域（Scope）** 的概念，一个操作（如赋值）只能影响到它所在的作用域内的值。如果不提供额外的接口，在函数外部看不到一个函数内部的变化。然而，倘若上述的程序直接在 LC-3 中执行，那么函数开头对 `R1` 的自增操作显然会反映到外部 —— 在 `callMe` 返回后，这个值就发生了变化。

除了这些显式使用的值，像是 `R7`（保存着返回地址）这样会被 `JSR` 隐式修改的寄存器，也会在一次跳转后发生变化，倘若我们连续使用两次 `JSR`，虽然的确可以“深入”两层函数，但此时连续使用两个 `RET`（相当于两次 `JMP R7`）却不能返回原来的地方了。

### 稍后回来

子程序可是“满脑子都想着自己”，如果想让寄存器在使用后还能恢复原来的值，我们就需要对每个寄存器进行**保存与恢复**：

```
FUNC
; 做点什么
; 保存寄存器的值
JSR FUNC
; 恢复寄存器的值
; 继续
```

显然，对于每次调用，我们都需要将这些值保存到内存不同的地方，否则它们会被下一次保存给覆盖掉。有很多办法来记录“刚才那些值放在哪里了”，比如每次调用都随机指定一个地址，并寄希望于我们的运气足够好，永远不要冲突。如果你觉得这个方法不怎么靠谱，那么就是时候使用**栈（Stack）** 了：

- 使用一个寄存器（通常是 `R6`），记录“上一个备份”在哪里。`R6` 本身不通过内存保存和恢复。
- 每次调用函数前，把 `R6` 向内存的某个方向挪一挪，划出一块空间，在那里保存各寄存器的值。
- 函数调用完成后，把 `R6` 向反方向挪动同样的距离，并将先前保存的值放回寄存器。

:::info 无言的约定

在这样的模型中，除 `R6` 外的寄存器通过内存保存和恢复值，而 `R6` 虽不存入内存，但只要在每次调用函数前都将 `R6` 增加，函数返回后又减少相同的值，那么 `R6` 在这次调用中就没有发生变化。如果每次函数调用都遵循整个规则，那么 `R6` 对于调用者来说就像是被“保存和恢复”了一样，尽管这种记忆是通过一种约定（而不是存储器）实现的。

:::

在通常的实现中，栈放在高地址（数值较大）的位置，向栈中添加值时会将栈指针下移（减少），并在它刚才的位置放入新的值。向栈中添加值称作**压栈（Push）**，而从栈中取出值称作**弹栈（Pop）**。如果使用这种布局，并把 `R6` 选作栈指针（指向栈的下一个可用位置），压栈和弹栈的代码如下：

```
PUSH
ADD R6, R6, x-1     ; 把 R6 下移
STR R0, R6, x1      ; 把 R0 放在 R6 刚才指向的位置

POP
LDR R0, R6, x1      ; 从 R6 的上一个位置读出值并存入 R0
ADD R6, R6, x1      ; 把 R6 移动回去
```

如果一次要保存多个值，可以通过一次性移动 `R6` 一大段距离，再使用带偏移的 `STR` 或 `LDR` 逐个将寄存器值存入，以避免反复修改 `R6`。

## In Your Blue Eyes（原曲使用）

<iframe style={{
    width: "100%",
    aspectRatio: 16 / 9
}} src="https://monster-siren.hypergryph.com/music/232231" referrerpolicy="no-referrer"></iframe>