---
sidebar_position: 2
---


# ICS-2 循序渐进

> 九片十片十一片，飞入丛中都不见。

下面是著名的斐波那契数列：

$$ F(n) = F(n-1) + F(n-2) $$

*当然，还要加上一些边界条件，但我们先不去管它……*

斐波那契数列拥有非常好的递推性质：新的一项等于前两项相加，也就是说，我们可以把前两项加起来得到第 3 项，然后扔掉第 1 项，再把第 2、3 项相加得到第 4 项……以此类推，我们可以在同等数量级的时间内计算出斐波那契数列中的任意一项。

现在来看另一个数列，它同样拥有递推结构，但有些不一样：

$$ Q(1) = Q(2) = 1, Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)) , n \ge 2 $$

无论你看到它的第一反应是“多么美妙！”还是“这啥玩意？”，都请先不要激动。这是 **Hofstadter Q 序列**，虽然它拥有这样一个看上去还算简洁的递推式，但要回答下面的这个问题却并不容易：

> $ Q(n) $ 是否对每个正整数 $ n $ 都有定义？（也就是说，$ n > Q(n-1) $ 和 $ n > Q(n-2) $ 是否总是成立？）

没有人知道这个问题的答案，也许你可以试着解答它。不过，这可不是我们今天的重点，我们要做的事情相比之下容易得多……

## 目标

给定正整数 $ 1 \le n \le 100 $，编写一个 LC-3 程序，计算 $ Q(n) $。

- `n` 存放在内存的 `x3100` 处，你的程序应把输出存放在 `x3101` 处。
- 至少从 $ Q(3) $ 开始的值必须由程序计算出（而不能预填在程序中）。
- 程序最多只能执行 10000 条指令（这已经很多了！）。

## 输入输出样例

输入：

```
x000a (10)
```

输出：

```
x0006 (6)
```

这是因为 $ Q(10) = 6 $。

## 指南

### 长短期记忆

与斐波那契数列不同，Hofstadter Q 序列不能简单把最近两项相加来得到下一项，因为 $ Q(n - Q(n-1)) $ 这样的部分很可能访问到**更早**计算出来的值。例如，在计算出 $ Q(100) $ 之前，我们不可能预知它要用到数列中的哪一项。如果不想每次被问到“$ Q(n) $ 是几”的时候都去现场计算（实在是太慢了！），我们就必须记忆每个计算出的结果。

存储数据最简单的方法是存入寄存器，它们也是唯一一种 CPU 可以直接用于计算的存储位置。遗憾的是，LC-3 只有 8 个寄存器，在 100 个数面前完全是杯水车薪。我们不得不将目光转向内存 —— 尽管它更慢，但它容量很大。

我们的计划非常简单：每次计算出 $ Q(n) $，就把它**放在内存的某个位置**，稍后要用到它时，就直接从内存中读出值。你可以随意指派 $ Q(n) $ 的位置，只要你等会还能找到它，不过通常的做法是在内存中使用**一块连续的内存空间**来存储数据，就像 C 语言的数组那样。例如，我们可以用 `x3201` 存储 $ Q(1) $、`x3202` 存储 $ Q(2) $ 等。

要读取和写入内存的某个地址，可以使用 `LDR` 和 `STR` 指令，它允许我们使用一个寄存器来指定目标地址：

```
LDR Rd, Ra, offset  ; Rd <- M[Ra + offset]
STR Rd, Ra, offset  ; M[Ra + offset] <- Rd
```

`LDR` 和 `STR` 先把 `Ra` 加上 `offset` 立即数，得出目标地址，再读写其中的数据。如果把 `offset` 设为 `x0`，那要读写的就是 `Ra` 当中的值所指定的地址。

:::note 地址，移动

为什么要有 `offset` 这样一个偏移量呢？在高级语言所生成的程序中，函数内的变量通常会在栈内被指派一个固定的地址（比如一个变量 `i` 可能位于栈内 `-48` 处）。由于栈的具体地址是不固定的（取决于调用者），编译器使用一个寄存器（不妨叫它 `Rs`）来记录当前栈的地址。这样，直接使用一条 `LDR Rd, Rs, -48` 这样的指令就可以读出 `i` 的值，而要是没有这个偏移量，我们就不得不劳烦 ALU 来算出目标地址，再去那里读写数据，最后还不能忘了还原寄存器的值 —— 这会让程序慢很多！

:::

由于 $ Q(n) $ 的每一项都只会用到先前已经计算出来的值，因此我们可以先计算和存储 $ Q(3) $、然后是 $ Q(4) $，直到 $ Q(n) $，而不用担心用到尚未计算出来的值。

### 比较大小

大多数现代 CPU 都拥有 `CMP` 或者衍生指令，用于比较两个数的大小。在硬件层面，这条指令逐位比较操作数的每一位，这样就能很快确定它们的大小关系。

遗憾的是，由于 LC-3 只有 4 位操作码，要留出一个给 `CMP` 这样的指令还是太浪费了。不过，尽管没有单独的指令来比较大小，我们可以使用减法和 `BR` 来做到相同的事情。例如，要比较 `Ra` 和 `Rb` 的大小，只需要：

- 用 `Ra` 减 `Rb`。
- 使用 `BRp`，如果跳转，就说明 `Ra` 比 `Rb` 大。
- 类似地，使用 `BRz` 和 `BRn` 可以判定相等或者小于关系。

“LC-3 也没有减法啊？”我就知道你会这么问，不过幸运的是，即使不添加新指令，这件事仍然是可以办到的：

- 减去一个数，等于加上它的相反数。
- 一个数（补码）的相反数，等于把它取反（`NOT`）再加 1（`ADD`）。

把这些组合在一起，我们就可以比较两个数的大小，这在循环中很有用，因为……

### 一遍又一遍

要从 $ n = 3 $ 一路计算到所提供的数，我们就需要使用**循环**。不过，在汇编层面没有循环这一概念 —— 任何非顺序执行的控制流程都需要通过分支跳转来实现。

最简单的循环结构是一个向上跳转的 `BR`：

```
LOOP

; 循环内容

BR LOOP
```

每次 `BR` 执行完成后，程序就会返回 `LOOP` 所在的位置，中间的指令于是在每次跳转后都被执行，这就构成了无限循环。

要给循环加上条件，只需要在循环内部合适的地方放置一条 `BR`（通常都是带条件的），跳出循环即可：

```
LOOP

; 其它代码

; 做些判断……

BRp LOOP_END    ; 视情况跳出循环

; 其它代码

BR LOOP

LOOP_END

; 后面的程序
```

### 开始与结束

还记得在机器语言中，代码的第一行代表程序的装载地址吗？汇编语言只是机器语言的另一种表示方式，它同样不能少了这些信息。在汇编语言中，需要使用 `.ORIG` 伪指令来指定程序的装载地址：

```
.ORIG x3000     ; 必须在开头
```

:::info 似真似幻？

`.ORIG` 是一条伪指令，也就是说，它并不像 `ADD` 等普通指令那样，会生成对应的二进制代码。伪指令用来指导汇编器进行某些动作，但它们本身在程序运行的时候是不存在的。在 LC-3 中，所有的伪指令都以 `.` 开头。

:::

LC-3 汇编还规定，必须使用 `.END` 来标记程序的终止位置，这有点像是高级语言中的 `}`，用来标识一个代码块的末尾。值得一提的是，`.END` 和 `HALT` 不能互相替代 —— `.END` 是给汇编器看的，告诉汇编器“源代码到此结束”，而 `HALT` 则是在运行时告诉系统“不要再继续执行指令了”。
