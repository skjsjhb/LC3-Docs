# 2-2 侦听事件

上一节已经说过，我们无法像 `onEnable` 一样直接在插件主类中添加 `onXXX` 方法来侦听对应的事件。那么，为了将我们的插件加入到 Bukkit **广播**事件的目标中，我们需要做一些额外的工作。

## 事件的类型

在 Bukkit 中，每种事件都被定义了一个专属的类型（事件也是一个对象！）。例如玩家登录到服务器的事件，就是 `PlayerLoginEvent`，这些你都可以在 [Paper 的 Javadocs](https://jd.papermc.io/paper/1.20.4) 上查找到。要侦听某种事件，我们就需要先找出与之对应的类型。

事件对象存在的意义当然不止其类型，这些对象本身还**存储了与事件相关的信息**。例如 `PlayerLoginEvent` 总是带有一个 `getPlayer` 方法，可以获取事件所涉及的玩家。这一点其实不难理解 —— 如果事件上什么信息也没携带，我们的插件即使捕捉到了这些事件，也不知道该做什么。

至于具体什么时候该使用什么事件，常用的事件有哪些，要如何从这些事件中提取需要的信息，我们都会在后面的实际项目中进行展示。

## 登记造册

让我们先考虑一个问题：如果你是 Bukkit 的设计者，你会要插件怎么侦听事件？

> Kirara：就让他们写一大堆方法呗。

—— 虽然她说得很随便，但也不能说她错，因为这确实是 Bukkit 采用的方式。插件将**侦听到事件后所要做的事情**写在一组方法中，然后交给 Bukkit 处理。只不过，这些方法写在的位置有点特殊。

还记得我们之前说过，“在 Java 中，一切都是对象”吗？事件是一种对象，那么侦听到事件后要做的事情，也就是所谓**事件侦听器（Event Listener）**，当然也是一个对象。既然是对象，那就应该有一个类来描述它。

好，恭喜，你已经摸索出了 Bukkit 中侦听事件的正确语法（的一半）：

```java
public class MyEventListener implements Listener {
    // 要做之事……
}
```

`implements` 看上去很陌生，不过在这里请各位先把它理解成 `extends`，实际上它们的功能也差不多。那么自然，`Listener` 似乎也是一个类，各位也就请先把它当成一个类。我们**创建一个类用于事件侦听，并且继承 `Listener` 类**，这是第一步。

现在，要侦听一个事件，就只需要做这样的修改：

```java
public class MyEventListener implements Listener {
    @EventHandler
    public void onPlayerLogin(PlayerLoginEvent e) {
        // 要做之事……
    }
}
```

我们只是**新增**了一个公开（`public`）方法 `onPlayerLogin`，它的**唯一参数**类型为 `PlayerLoginEvent`，并且**没有返回值**（`void`）。此外，我们还添加了一个**注解** `@EventHandler`。

?> `@EventHandler` 的作用是告知 Bukkit：“这是一个事件侦听器。”就像我们用 `@Override` 告知 Java 我们在重写方法一样。

好啦，这样 `PlayerLoginEvent` 这一事件，就能被 `onPlayerLogin` 方法捕捉到。只需要在其中填上要做的事情，Bukkit 就会**自动在相应的事件发生时，调用 `onPlayerLogin` 方法** —— 这不就是我们在 `onEnable` 中已经做过的事情嘛！

> **到底怎么回事？**
> 
> Bukkit 使用一种复杂的机制来搜索我们创建的事件监听器。在这个例子里，它**扫描 `MyEventListener` 类中定义的方法**，并将它们的唯一一个参数作为**要侦听的事件类型**。随后，Bukkit 自己在内部登记造册，每当有指定类型的事件发生时，Bukkit 就调用扫描到的方法。

> **你是职业选手吗？**
> 
> Java 拥有一项很重要的机制，叫做**反射（Reflection）**。相比于 C 和 C++ 这样的静态语言，反射能允许 Java 在程序运行的时候获取与程序本身相关的信息，包括但不限于读取甚至修改方法列表、参数、访问修饰符等。Bukkit 使用反射获取方法列表，再提取相应的类型参数，完成事件侦听器的注册。

这里必须提及的一个事实是，当我们侦听事件时，我们只能选择**要侦听事件的类型**（在这里是 `PlayerLoginEvent`），而无法做其它的筛选。如果还想提出些额外的要求，就需要在侦听器方法内部编写额外的代码。这是有些不方便，但这是规范。

在这样声明后，Bukkit 就会将类型为 `PlayerLoginEvent` 的事件传递给我们的侦听器，这正是“有选择地处理”的体现。

顺便一提，如果要添加多个事件侦听器，**不必创建额外的类，只需要再添加一个方法**就可以了，例如：

```java
public class MyEventListener implements Listener {
    @EventHandler
    public void onPlayerLogin(PlayerLoginEvent e) {
        // 要做之事……
    }

    @EventHandler
    public void onSomeOtherEvent(MyCustomEvent e) {
        // 要做之事……
    }
}
```

此外还有一些细节需要注意：

- 侦听方法的名称可以随意选择（当然要是符合语法的啊），不会影响事件的侦听和处理。

- 侦听方法的返回值类型为 `void`。
  
  ?> Bukkit 通常不会关注事件侦听方法的返回值，所以即使返回些东西也没有实际意义 —— 没人会用它们（笑）。

- 侦听方法是公开的（`public`）。
  
  ?> 这涉及到 Bukkit 调用你指定方法的机制，Bukkit 通过一种非常规的机制调用这些方法。尽管 Bukkit 有办法调用 `protected` 甚至 `private` 的方法，但为了规范起见，最好不要这么做。

- 侦听方法只能有一个参数，其类型是**要侦听事件的类型**。
  
  ?> 你已经知道 Java 使用方法名和参数列表来辨识方法，所以参数的名称是无所谓的。

## 可行的选择

在学习了如何侦听事件后，有人很自然就要问出一个问题：

> Kirara：什么类型都可以侦听吗？能不能侦听什么“字符串事件”呢？

答案是否定的，至少你应该知道，`String` 肯定是不行的，因为它看上去就不像是个事件。

在 Bukkit 的命名中，事件类**通常都以 `Event` 结尾**。例如玩家移动的事件叫做 `PlayerMoveEvent`，方块被破坏的事件叫做 `BlockBreakEvent` 等。

> Kirara：只要是以 `Event` 结尾的类，就可以被当作事件侦听吗？

……这丫头没救了，不过抛开她总是喜欢从形式上看待问题不谈，在 Bukkit 中，**所有的事件都直接或间接地继承自 `Event` 类**（全名 `org.bukkit.event.Event`），而 Bukkit 刻意地将这些事件都命名成了以 `Event` 结尾的形式。所以，严谨地说：

**在 Bukkit 中，可侦听的事件所属的类型，必须是 `Event` 的直接或间接派生类。**

读者可能会想，只要是继承了 `Event` 的类，应该就可以被侦听了。确实本来也应该如此，然而，遗憾的是，哪怕一个类的确是继承自 `Event` 的，也**不代表它就可以被侦听**。典型的例子是 `PlayerEvent`，它是 `Event` 的直接子类（如图所示），但如果想要侦听它，却是办不到的。

![.](https://imgos.cn/2024/08/10/66b70c619a697.png)

在 Bukkit 中，一个事件若要能被侦听，需要满足一些特殊的条件。讲解哪些事件可以侦听已经超出了本节内容的范畴，事实上在开发插件中也很少用到。不过，如果你真的很感兴趣，可以看看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 我们已经说过，Bukkit 能将事件和它的一系列侦听器一一对应起来，要做到这件事情，Bukkit 需要用到事件类的一个特殊方法：
> 
> ```java
> public static HandlerList getHandlerList();
> ```
> 
> 这个 `HandlerList`，顾名思义，就代表“本事件的侦听器”。一个事件类，如果存在这个方法，那么就代表 Bukkit 已经准备好侦听它，而要是没有，那肯定就是不行。
> 
> 尽管我们还没讲解 `static` 的含义，不过在这里可以先告诉读者：`static` 标记的方法无法被继承。也就是说，即使一个类定义了 `getHandlerList`，它的派生类也不会继承这个方法。换而言之，每个类都需要独立地定义 `getHandlerList` 方法，才能用于事件侦听器的注册。

---

有关事件侦听的内容，到这里就讲得够多了，在下一节里，我们要对已经学过的 Java 知识再进行一些拓展，以便于我们完成下一个项目。