# Kotlin 泛型

离开了有趣但稍有些复杂的面向对象（事实上从未离开，面向对象的设计方法会在余下的 Kotlin 章节中一直伴随我们），我们要花费一节的时间来讨论泛型编程。尽管函数式编程、面向对象设计和自动内存管理等一系列现代语言所具备的功能（甚至 C++ 也有某种程度的自动内存管理）已经深深动摇了 C 在现代软件工程中的地位，但真正让 C“跌下神坛”的，笔者认为莫过于泛型。泛型是一个从零到一的转变，而且对比之下令 C 类型系统中的缺陷暴露无遗。尽管 C 也有某些办法实现泛型（例如使用大量的宏），但总的来讲并不如大多数现代语言来得优雅。

## 点对点问题

假设你刚才实现了一个令人兴奋的列表，它能够以 $ O(1) $ 的时间复杂度（非常快！）进行插入、删除、搜索等操作，你通过 Kotlin 这样实现它（这里只列出接口）：

```kotlin
interface FastList {
    fun add(v: Int)
    fun remove(i: Int)
    fun find(v: Int): Int
}
```

这个设计有一个问题：它只能存储整数 `Int`。如果将来要能存储小数呢？你于是又创建一个类：

```kotlin
interface FastListDouble {
    fun add(v: Double)
    fun remove(i: Int)
    fun find(v: Double): Int
}
```

好吧，这算是解决了 `Double` 的问题，那么 `String` 呢？`Boolean` 呢？还有 `Cup`、`Greeter`、`Complex` 这些标准库中或者自定义的类……你的列表要支持的类的个数可能是**任意多**的，这不可能通过手写每一个类来做到。“真是麻烦，我还是用 C 吧！”你心想，于是就把手伸向了万恶之源 ——

```c
struct FastList {
    // ...
    void* values;
};
```

噢，不，你不能，`void*` 是这个世界上最糟糕的东西之一，它代表“指向未知类型的指针”。它以一己之力就足以粉碎 C 语言原本缜密的类型系统，在 C++ 里到处捣乱弄得不可收拾，并且还试图从那里逃出来，逃到我们优雅的 Java 和 Kotlin 中。在每次使用这个设计时，你都得花时间来想想列表中存储的东西到底是什么，因为一旦搞错，并且将 `void*` 转换成了错误的类型，引发的内存错误足以让有经验的软件工程师都头疼上好一阵子。

---

这个问题的根本原因，在于我们不知道使用列表时所要用到的**具体类型**。既然不知道，那么我们就**用一个“参数”来代替它**：

```kotlin
interface FastList<T> {
    fun add(v: T)
    fun remove(i: Int)
    fun find(v: T): Int
}
```

通过在类名后加上一对尖括号 `<>`，并在其中提供一个或多个**类型参数（Type Parameter）**，`FastList` 就成为一个具备**泛型（Generic）**的类。它向使用者声明：“我需要知道你打算存储的元素的类型”。所获取的类型参数和函数中的参数非常相似，可以**在整个类定义当中使用**，包括参数、返回值、局部变量、属性、Lambda 函数等的类型。

尔后，当我们打算使用 `FastList` 时，只要为它提供所需的类型：

```kotlin
fun main() {
    val li: FastList<Int> = fastListOf(1, 2, 3)
    val ls: FastList<String> = fastListOf("ciallo", "world", "!")
    li.add(4)
    ls.find("ciallo")
}
```

这里我们创建了两个变量，类型都是 `FastList`，但分别以 `Int` 和 `String` 作为参数。实际上，**想要多少种不同的类型就可以有多少种！**只要把所需的类型填在尖括号里对应的位置上就好了。

?> 提及泛型类型时，为了不引起歧义，通常会带上它的参数，在这里，`li` 变量的完整类型是 `FastList<Int>`，而 `ls` 的则为 `FastList<String>`。

---

泛型除了可以应用在类上，也可以应用在方法（以及一般函数）上：

```kotlin
fun <T> foo(item: T) {
    // ...
}
```

在这里，界定类型参数的尖括号要加在方法名之前，所获取的类型参数可以在整个方法定义中使用。调用方法时，类型参数加在方法名之后：

```kotlin
fun main() {
    foo<Int>(1)
}
```

---

当然，由于 Kotlin 强大的类型推断功能，类型参数常常是可以省略的，不论是类还是方法中的类型参数都是如此。但是，当 Kotlin 不能自动推断，或者推断不符合期望时，手动指定类型仍然是必要的。

## 证明你是你

请看下面的例子：

```kotlin
fun foo(li: FastList<Number>) {
    // ...
}

fun main() {
    val a: FastList<Int> = fastListOf()
    foo(a) // 错误
}
```

上面的程序会在编译时出错，因为类型为 `FastList<Int>` 的值不能被赋给 `FastList<Number>`。或许你会觉得不可思议，一列整数难道不能被当作一列数字看待吗？在读取方面来看，好像确实如此，但是别忘了列表还有写入功能，如果 `FastList<Int>` 可以“自然”地转换到 `FastList<Number>`，那我们就能将任何数字都塞入这个本应只包含整数的列表中，这就会造成错误。

在大多数情况下，参数类型不同的泛型之间**完全不兼容**（不能自动互相转换），只有在以下两种情况，两种泛型**或许**是可以转换的：

- `G<D>` 可以自动地**向上转换**到 `G<B>`，如果每个 `D` 都是 `B` 的派生类，而且在 `G` 中，泛型参数只用于读取（多数情况下是方法返回值）。

- `G<B>` 可以自动地**向下转换**到 `G<D>`，如果每个 `D` 都是 `B` 的派生类，而且在 `G` 中，泛型参数只用于接收（多数情况下是方法参数）。

如果有多个参数，需要每个参数都满足其中同一个条件。

---

尽管有这样的条件，但 Kotlin 并不会自动分析你的类并判断能否转换，因为这样**不稳定** —— 即便是类内部最微小的修改也可能会导致泛型之间的转换关系发生变化，这将确保类型正确的责任全部留给了使用者，不利于程序的维护。如果要声明某个类型参数只用于读取或接收，必须**显式地指出这一点**：

```kotlin
class FastList<in T> {
    fun add(v: T)
    fun remove(i: Int)
    fun find(v: T): Int
}
```

如果某个参数只用于读取，在其前方加上 `out`；如果只用于接收，则加上 `in`。当你正确地标记了各个参数，那么满足条件的泛型就可以在合适的条件下自动转换。

## 类型严选

假设你正在实现一个基于泛型的加法函数：

```kotlin
fun <T> add(a: T, b: T): T = a + b
```

这个程序看上去很优雅，但遗憾的是它不能通过编译，原因在于并非每个类都有加法运算符。泛型参数的值可能是任意的，而 Kotlin 把处理这些情况的责任交给了泛型的实现者。如果需要对可用的类型参数加以限制，则必须在定义时指出：

```kotlin
fun <T : Number> add(a: T, b: T): T = a + b
```

通过在类型参数后加上冒号 `:` 和类名，我们可以**要求 `T` 是 `Number` 或其派生类**（或者说 `T` 兼容于 `Number`），由于 `Number` 中已经明确定义有加法运算，因此这个程序能正常工作。

?> 读者可能会好奇是否能要求 `T` 是某个类的基类，这一点在 Kotlin 中无法做到 —— 不是因为它难以实现，而是因为这样做并没有意义。类型筛选通常是为了要求更多信息，这一点与要求泛型参数“更粗糙”是相悖的。

---

有时你可能希望 `T` **同时是多个类的派生类**，这也可以办到，但是方法有些不同：

```kotlin
class Foo<T> : Super() where T : Clazz1, T : Clazz2 {
    // ...
}

fun <T> foo(): Int where T : Clazz1, T : Clazz2 {}
```

通过在类型定义或方法体定义的大括号 `{` 之前（即类型头部和方法头部的最后）**添加 `where` 关键字和一列条件**，我们可以对 `T` 提出不止一个要求。在上面的例子里，`T` 必须同时兼容于 `Clazz1` 和 `Clazz2`，方能通过编译的检查，同时，在对应的定义中，我们可以认为 `T` 同时具有 `Clazz1` 和 `Clazz2` 的属性与方法。

?> 读者可能会担心，如果 `Clazz1` 和 `Clazz2` 都是普通类，而且具有同名的方法，会不会引发类似钻石难题的冲突。这一点无需担心，因为若所要求的多个基类之间有冲突，那么满足这些条件的 `T` 是不存在的，这样的代码从一开始就不合逻辑。

## 在结束之前

泛型是 Kotlin 乃至绝大多数现代编程语言中的一个重要特性，它将类型安全推向了更广泛的范畴，也让自定义类型的灵活度极大幅增加。几乎所有的程序都会（在某些时刻）用到泛型，或者能利用泛型来简化。如果只学习过 C 语言，泛型会是一个很新的概念，但与它所能为你节省的时间相比，理解它所需要的时间几乎是微不足道的。

## 练习题

1. 在 Kotlin 标准库中，接口 `List<T>` 代表只读列表，而 `MutableList<T>` 代表可读可写列表。现在有这样的事实：`List<Int>` 可以自动转换到 `List<Number>`，但 `MutableList<Int>` 却不能自动转换到 `MutableList<Number>`，这是为什么？

2. 整数排序算法的函数形如（不含函数体）：
   
   ```kotlin
   fun sort(arr: Array<Int>) { /* ... */ }
   ```
   
   用泛型改写该函数头，使之可以支持任何可比较类型。提示：在 Kotlin 中，可比较类型都实现了 `Comparable` 接口。

> **解答**
> 
> 1. `List<T>` 由于是只读列表，因此类型参数 `T` 只被用于读取（这一点需要查看 `List` 的定义才能确定，不过在此之前，你可以大胆地这样假设），而 `Number` 是 `Int` 的基类，因此可以将 `List<Int>` 向上转换到 `List<Number>`。相比之下，`MutableList<T>` 由于涉及写入操作，就不能安全地进行转换。
> 
> 2. 改写后的函数头如下：
>    
>    ```kotlin
>    fun <T : Comparable> sort(arr: Array<T>) { /* ... */ }
>    ```
