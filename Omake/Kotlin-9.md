# Kotlin 扩展函数

离开了面向对象和泛型，我们也就已经算是涉足过了这门有趣语言的核心部分。在接下来的章节中，我们会从理论逐渐走向应用，并且在这个过程中，逐渐体会到 Kotlin 是如何令复杂的程序设计工作变得简单的。

## 让我访问！

请看下面的程序：

```kotlin
fun padEnd(s: String, n: Int, c: Char): String {
    var a = s
    repeat(n - s.length) {
        a = a + c
    }
    return a
}
```

`padEnd` 函数在给定的字符串 `s` 之后连续添加字符 `c`，直至字符串的总长度来到 `n`。注意这里的加法 `+` 符号已经由 Kotlin 重新定义，将一个 `String` 类型的值与 `Char` 类型的值“相加”，就是将它们拼在一起。当然，这个算法称不上高效，但我们暂且先忽略这个问题。

你会注意到，`padEnd` 函数没有与任何类相关联，它的功能非常基本 —— 操作字符串，这种比较基本的操作（但没有“那么”基本），在很多项目中都会大量出现，它们被称为**工具函数（Utility Functions）**，也称**实用函数**。当这样的函数逐渐多起来时，要**找到需要使用的工具函数**是一件很麻烦的事情。

回想一下我们先前是怎么解决类似的问题的 —— 将操作数据的**方法**与数据的**属性**合并在**类**中。如果我们能把 `padEnd` 也合并到 `String` 类当中就太好了，但是很遗憾，`String` 类已经定义好，无法再修改（即便可以修改，也不应该这么做），标准库中的类通常只包含最基本的功能，而将更高级的操作留给应用程序实现。

> **到底怎么回事？**
> 
> 你或许会想，为什么标准库不事先考虑到所有常见的操作，并将它们加入到标准库中。问题在于，这么做会使得标准库庞大无比，而且难以维护 —— 相同的事情已经在 C++ 中发生过了，而它们的编译器现在不得不以沉重的代价（例如友元、选择编译等麻烦的语言规则）来解决这些历史遗留问题。
> 
> 有鉴于此，在设计任何程序时，都要避免在一个“盒子”内塞入太多东西。这个盒子可以是类、方法、文件或者整个项目本身，它们统称**模块（Module）**。**始终保持模块的精简，优先组合而非扩充**，这样你可以很容易地替换或者修补单个模块，而不致对着长长的代码无从下手，最后不得不整体推倒重来。因此，即便 `String` 不是标准库中的定义，而是你自己实现的类，在将 `padEnd` 加入到它的方法当中之前，也必须先考虑 —— **这么做真的必要吗？**

我们不想也不应将 `padEnd` 合并到 `String` 类中，但我们想要享受面向对象设计的便利。假设 `padEnd` 已经在 `String` 中定义，我们就可以写出这样的代码：

```kotlin
fun main() {
    val a = "12"
    println(a.padEnd(4, '0')) // 1200
}
```

这样（至少在形式上），我们能够看出 `padEnd` 与字符串 `a` 之间的关联关系。此外，这种后缀式写法可以很方便地进行**链式调用（Chained Call）**：

```kotlin
// 使用链式调用
a.trim()
 .plus("1234")
 .replace("xyz", "abc")
 .padEnd(4, '0')
 .substring(4)

// 不使用链式调用
substring(padEnd(replace(plus(trim(a), "1234"), "xyz", "abc"), 4, '0'), 4)
```

下面这样的代码看上去就让人头疼。链式调用每次**以上一个方法（或属性）的值作为对象**，在其上继续调用方法，这种写法能够**连续对某个对象进行一系列的操作和转换**，符合我们设计程序时的顺序思维。而且，链式调用还不需要你反复把光标挪到开头去添加函数名，使得编写代码本身的效率也得到大幅提升。

---

为了享受这样的便利，Kotlin 提供了名为**扩展函数（Extension Function）**的功能：

```kotlin
fun String.padEnd(n: Int, c: Char): String {
    var a = this
    repeat(n - length) {
        a = a + c
    }
    return a
}
```

?> `this` 在出现在方法当中时，代表**方法被调用时所属的对象**。例如，`"1234".padEnd()` 会使得在 `padEnd` 中，`this` 的值为 `"1234"`。

定义扩展函数的语法和定义方法差不多，唯独需要在方法名前加上类名和点号 `.`，其余的部分都和方法没有区别 —— 可以不加任何前缀地使用类中已经定义的（公开）方法、属性，甚至其它扩展函数，也正是因此，我们移除了原先的第一个参数 `s`，因为要处理的字符串就是“当前对象”。此外，对基类定义的扩展函数也可以通过派生类来使用，就像继承一样。

---

在使用扩展函数时，有以下几个特点需要注意：

- 扩展函数的优先级低于方法 —— 如果类中已经定义了相同签名的方法，则调用时 Kotlin 总会选择类中所定义的方法。

- 扩展函数本质上是单独的函数，不属于类的一部分。

- 扩展函数和其所属的类都需要对调用扩展函数的代码可见。例如，尽管 `String` 是公开的，但如果 `padEnd` 以 `private` 修饰，则外部代码仍然无法调用它。

## 形式转换

你肯定已经在 C 语言中写过这样的代码：

```c
struct Student s;
s.id = 1;
s.gpa = 8.0;
addStudent(&s);
```

在 Kotlin 中，相同的代码会写作：

```kotlin
val s = Student()
s.id = 1
s.gpa = 8.0
addStudent(s)
```

我们先创建了一个变量，然后借由这个变量对其进行一列操作，最后再使用它。问题在于，变量 `s` **并不是必要的** —— 最终给 `addStudent` 提供的参数就是一开始新建的对象，使用变量 `s`，仅仅是我们需要对它进行一列操作，而不得已的选择。为了创建变量，我们不得不打破了优美的链式写法，再次开始挪动光标，这一点令人非常遗憾。

有没有什么方法，可以以新建的 `Student()` 为初始对象，对它进行链式调用，完成同样的操作呢？答案是肯定的：

```kotlin
Student()
.apply {
    id = 1
    gpa = 8.0
}
.let { addStudent(it) }
```

这是什么意思？`apply` 和 `let` 都是 Kotlin 当中的扩展函数，它们对所有类都有定义，并且接受一个 Lambda 函数作为参数（还记得吗，Lambda 函数以大括号 `{}` 定义，作为参数传入时可以省去小括号 `()`），这个 Lambda 函数中包含了**要对被扩展的对象所进行的操作**。除了 `apply` 和 `let`，这个家族还有 `run` 和 `also` 两名成员，它们的功能都很相似 —— **将给定的对象传递给你指定的 Lambda 函数**，但是这个传递方法，却有所区别：

- `let`：对象作为 Lambda 函数的参数传入，并且 `let` 的返回值是 Lambda 函数的返回值。

- `run`：在 Lambda 函数内，`this` 指代给定的对象，可以直接使用对象的方法而无需前缀，并且 `run` 的返回值是 Lambda 函数的返回值。

- `also`：对象作为 Lambda 函数的参数传入，但是 `also` 的返回值是对象本身（Lambda 函数的返回值被丢弃）。

- `apply`：在 Lambda 函数内，`this` 指代给定的对象，可以直接使用对象的方法而无需前缀，但是 `apply` 的返回值是对象本身（Lambda 函数的返回值被丢弃）。

在上面的例子中，`apply` 后所跟的 Lambda 函数中可以使用 `id` 和 `gpa`，和类中的方法别无二致，我们利用这一点对它们进行赋值，赋值之后，`apply` 仍然返回被操作过的 `Student` 对象。这正是它得名的原因 —— 将一列操作**应用**在指定的对象上，并且传递给下一个链式调用。

类似的，在 `let` 后所跟的 Lambda 函数中，`Student` 对象被作为第一个参数传入，我们将它传递给 `addStudent`。

?> 如果不通过 `{ a, b -> /* ... */ }` 的形式来声明 Lambda 的参数，则第一个参数会默认命名为 `it`，可以直接使用。

---

这四个函数被称为**作用域函数（Scope Function）**，因为它们能够改变变量的作用域（事实上是隐式地创建新的变量），将它们以各种方式从外部挪到 Lambda 函数内，并且你可以选择使用返回值还是对象本身，以便于进行链式调用。

## 在结束之前

这一节不算长，因为扩展函数本身不是一种复杂的机制，它仅仅是允许**通过类似方法调用的语法，借助对象和链式调用，简化代码的编写**。在大量实际项目的统计结果中，能够进行链式调用的写法平均为开发者节约了大约 30% 左右的编码时间，而扩展函数正是在不破坏类的精简性的前提下实现了这一点。Kotlin 为我们定义了许多扩展函数，其中有四个特殊的作用域函数，它们作为面向对象和函数式编程的接口，能用于大幅简化代码的编写。

## 练习题

1. 尝试实现 `let` 扩展函数。
   
   提示：你将需要使用两个泛型参数 `T` 和 `R`，一个代表当前对象的类型，一个代表 Lambda 返回值的类型。

2. 在 C 语言中，如果想要交换两个变量的值，你将需要一个临时变量：
   
   ```c
   void swap(int *a, int *b) {
       int temp = *b;
       *b = *a;
       *a = temp;
   }
   ```
   
   （当然，我知道你会使用异或来反驳我，但我们暂且先不考虑算术操作）
   
   在 Kotlin 中可以不必这么做，尝试使用 `also` 扩展函数，在不使用临时变量的前提下，完成两个 `Int` 变量数值的交换。

> **解答**
> 
> 1. 一种实现方法如下：
>    
>    ```kotlin
>    fun <T, R> T.let(f: (T) -> R): R = f(this)
>    ```
>    
>    `let` 需要给 Lambda 函数 `f` 的参数 `it` 提供具体类型，因此必须对于泛型 `T` 定义 `let`。在实际使用时，Kotlin 会将 `T` 换成对象的实际类型，从而在**保持类型信息**的前提下，对所有类型定义了 `let`。同样的，由于需要保持返回值类型，因此使用泛型 `R` 代表它。
>    
>    由于 `let` 是一个扩展函数，因此在它**自身的函数体**中（注意不是 Lambda 的函数体），我们可以使用 `this` 获得当前对象，将其传递给 `f` 即可。我们还使用赋值返回 `=` 符号简化了返回值的传递。
>    
>    作为参考，以下是另外三个作用域函数的实现：
>    
>    ```kotlin
>    fun <T, R> T.run(f: T.() -> R): R = f()
>    
>    fun <T> T.apply(f: T.() -> Unit): T {
>        f()
>        return this
>    }
>    
>    fun <T> T.also(f: (T) -> Unit): T {
>        f(this)
>        return this
>    }
>    ```
>    
>    `run` 和 `apply` 中 `T.() -> R` 这样的写法被称为作用域绑定，它使得在 `f` 中可以直接使用 `T` 的方法和属性。如何使用作用域绑定已经超出了我们要讨论的范畴，如果你有兴趣，可以去搜索一下相关的资料。
> 
> 2. 一种实现方法如下：
>    
>    ```kotlin
>    var a = 3
>    var b = 5
>    a = b.also { b = a }
>    ```
>    
>    赋值语句会先计算赋值符号 `=` 的右边，注意 `also` 在执行完 Lambda 函数后返回其**调用时**所使用的对象，而 `also` 在被**调用时**，`b` 还存放着原先的值不变，因此 `also` 会在**执行了 `b = a` 之后，返回 `b` 原先的值**，我们再将其赋给 `a` 即可。
>    
>    这里其实并非没有产生临时变量，而是隐式地使用了 `also` 的返回值作为临时变量，在 `also` 开始调用时“捕捉”`b` 的值，而在赋值结束后将其传递给 `a`。请仔细体会这一点，感受 Kotlin 是如何利用这样的细节将程序变得简单的。
