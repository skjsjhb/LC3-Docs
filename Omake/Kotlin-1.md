# Kotlin 基础知识

你已经学会了 C —— 至少已经学过了 C。编程语言之间大多有相似之处，在细节方面却有所不同。至少，语言基础的学习，还得从头再来，不过，有~~异世界的记忆~~先前的经验，这一次你会更快掌握相关的内容。

?> 在学习新语言时，最忌讳的是惯性思维。每种语言都有自己的特点，需要单独掌握。记住，**Kotlin 不是 C**。

## 我们从一个数字开始

```kotlin
1
```

这是数字 1，可爱无害 —— 1 能有什么坏心思呢？它只不过是一个**字面量（Literal）**而已。字面量，也就是“能直接写出来的东西”。

---

让我们再来写一些字面量：

```kotlin
28
0x55aa
42.195
```

这是十进制数 `28`、十六进制数 `0x55aa`（即十进制下的 `21930`）以及小数 `42.195`，它们分别是**整数（Integer）**和**小数（Floating Point）**。

---

```kotlin
true
false
```

这是**布尔值（Boolean）**，它们只有两个，`true` 代表“是”，`false` 代表“不是”。

?> 布尔值是一种单独的类型，它们不是数，也和数**没有关系**。什么？`0` 就是 `false`？—— 别忘了，**Kotlin 不是 C**。

---

```kotlin
"ciallo, world"
"这段代码永远不会被人看见，是不是很神奇呢？"
```

这是**字符串（String）**，在一段文字的两边加上引号，就把它转换为一个字符串。

---

```kotlin
null
```

这是**空值（Null）**，代表“什么也没有”。`null` 在 Kotlin 中是一个相当重要的角色，只要你允许，任何变量都**可以**是 `null`，反之，你也可以在 Kotlin 中完全规避掉 `null` 的使用 —— 我们后面会提及。

---

字面量很简单，但是也太无聊了，`1` 和 `2` 不会自动结合起来变成 `3`，而 `"ciallo, world"` 也不会自己跑到屏幕上，这可没什么意思。

## 聚变反应

将字面量用一些东西连起来：

```kotlin
1 + 2
```

这是一个**表达式（Expression）**，代表“对 `1` 和 `2` 执行加法 `+`”，表达式本身描述的是加法这一**行为**。当然，你会立马算出 `3`，这是这个表达式的**值（Value）**，表达式中的加号 `+` 是**操作符（Operator）**，由于加法总是将两个数相加，因此它是一个**二元运算符（Binary Operator）**。

---

```kotlin
0.8 < 0.11
```

这里的操作符是小于号 `<`，它尝试进行比较，确定左侧的数是否小于右侧的数。很显然，上式不成立，**不成立就是“不是”**，也就是说，该表达式的值是（布尔值） `false`。像这样的比较运算符，都是以布尔值的形式给出比较的结果的。

---

```kotlin
"Sakura" == "Kumo"
```

这里的运算符改成了相等运算符 `==`，它能比较左右两侧的值是否**内容相等**，这两个字符串并不相同，因此该表达式的值为 `false`。

?> 相等运算符 `==` 有两个等号，如果你在 C 中已经为此花费了很多时间，那么今后就要尽量避免了（当然，IDE 会帮助你）。

---

```kotlin
1
```

等下，这不是**字面量**吗？嗯，在 Kotlin 中，单独的字面量也是一个表达式，该表达式的值是该字面量的值。

---

表达式也可以写得更长：

```kotlin
0.2 * 0.4 < 0.11
```

这个表达式里有两个运算符，究竟先算哪一个？实际上，只能先算乘法，因为如果先算 `0.4 < 0.11`，结果是 `false`，然后表达式变成 `0.2 * false`，这就没法算了。

但是，如果表达式有几种不同的读法呢？比如：

```kotlin
1 + 2 * 3
```

在数学里面，我们会先算乘法，这在 Kotlin 中也是一样的。运算符的乘除优先于加减，但带括号的优先。如果我们想要得到 `9`，就必须写成：

```kotlin
(1 + 2) * 3
```

---

表达式能算出来结果，这很好，可是算出来的结果去哪里了？利用表达式可以在程序中完成一些计算，但要在程序的其它部分使用这些值，就需要 ——

## 无法改变的，想要改变的

你可以使用**变量（Variable）**来代表某个值：

```kotlin
val a = 1
```

和 C 中很相似，唯一的区别是 Kotlin 中创建变量并不需要特意指定类型，Kotlin 编译器会自动推断。在这个例子里，`a` 的类型是整数。抛开这点不谈，我们刚才**定义（Define）**了一个名为 `a` 的变量，它的值是 `1`。

---

你可能会想，我们是不是可以这么做：

```kotlin
val a = 1
a = 2
```

答案是**不行**，因为使用 `val` 定义的变量是**不可变**的。什么？**变**量不可变？嗯，这的确是 Kotlin 的逻辑，使用 `val` 定义的变量是**不可变变量（Immutable Variable）**，变量的值必须在定义时指定，并且此后不能再更改。

?> 不可变变量不是**常量（Constant）**，二者在 Kotlin 的语言规范中仍有区别。

如果要定义一个**可变变量（Mutable Variable）**，就要使用 `var` 关键字：

```kotlin
var a = 1 + 2
a = 8
```

由 `var` 定义的变量可以在定义后再修改它的值。

学过 Python 的读者可能会想这么做：

```kotlin
var a = 1
a = "String"
```

这也不行，因为 Kotlin 是**强类型语言**，变量的类型在定义时确定，此后不可以再更改。即便一个变量是可变的，能改变的也只是它的值，而非类型。

> **到底怎么回事？**
> 
> 变量的不可变性比想象中要重要，这是最近十年来程序设计界所达成的共识。绝大多数的程序漏洞，都是源自改变了不该改变的东西，或者调用了不该调用的函数。请记住这条程序设计理念之一：
> 
> **"Document it or forbid doing so."**
> 
> 一开始，我们可以让所有的变量都不可变，然后，等我们需要可变变量的时候，再去明确地用 `var` 声明该变量可变，这样我们可以刚刚好让那些必须改变的东西可变，但绝不会超出这个范围。在调试和性能优化方面，这都能帮我们很多的忙。

---

当使用可变变量时，有时候并不能在一开始确定它的值，Kotlin 考虑到了这种情况，并且允许我们稍后再给可变变量赋值：

```kotlin
var a: Int
a = 2
```

要注意的是，由于 Kotlin 是强类型语言，而若不对变量进行初始化，Kotlin 无法推定 `a` 的类型，因此必须**显式（Explicit）**地声明 `a` 的类型。类型声明与 C 中不同，要通过冒号 `:` 连接在变量名之后。Kotlin 中代表整数的类型是 `Int`（注意大小写）。

尽管可以稍后再初始化变量，但这不意味着 `a` 会有一个默认值。事实上，必须先给 `a` 赋值，才能使用它。下面是典型的错误用法：

```kotlin
var a: Int
val b = a + 1
```

与 C 编译器只是温和地显示一条警告不同，Kotlin 编译器很强硬，它会拒绝编译这样的代码。

## 在结束之前

这就是本节的全部内容了，我们介绍了有关 Kotlin 最基本的语法（表达式和变量），这些知识虽然基础，但它们是后续构成更复杂的程序所必需的基本元素。
