# 实验 2：机械化证明

*注：中文版为阅读理解方便而编写，与原文有所不同，请**务必同时参考英文原文**。*

## 概述

> 千淘万漉虽辛苦，吹尽狂沙始到金。

已经搞定实验 1 了？没有？啊？**被**它搞定了？行吧行吧，过去的事情就让它过去吧。用机器码来写程序虽然看上去很帅，但要满足实际需求那还是太困难了。本实验，也就是实验 2，将向你介绍汇编语言的使用。好吧，被实验 1 弄得灰头土脸也不要紧，给你自己（还有你的电脑）充充电，再来和实验 2 大战个三百回合。

## 背景

你肯定在哪里看见过这张梗图：

![](https://img.picui.cn/free/2024/10/10/67075167aa482.png)

**“已用 C++ 核实。”** 确实如此，作为计科人，实用主义乃是至上。哥德巴赫猜想确实很难彻底解决，不过我们已经测试了 $ 4 \times 10^{18} $ 内所有的数，对于数学以外的实际用途，差不多也足够了，不是吗？（当然，你可能会有不同的意见）

我们可以用 LC-3 来部分地验证哥德巴赫猜想，但是这个任务对于可爱的 LC-3（还有可爱的你）来说有点太过分了。我们换一个简单点的问题（当然，如果你是数学家，你可能不会这么觉得）：

> **Collatz 猜想**
> 
> 1. 选一个正数。
> 
> 2. 每次操作做以下两件事之一：
>    
>    - 如果是奇数，就将其乘 3 再加 1：
>      
>      $ a_{n+1} = 3a_n + 1 $
>    
>    - 如果是偶数，就将其除以 2：
>      
>      $ a_{n+1} = \frac{a_n}{2} $
> 
> 3. 这么做了几次之后，它会变成 1。

看上去很简单？来证明一下！哎呀哎呀，别打我，我们不是在上数学课啦。我是说，用 LC-3 来**验证**一下它。

## 任务目标

对给定的一个数，按上述步骤验证 Collatz 猜想，并给出所需操作的步数。

- 输入数据存放在内存的 `x3100` 处。

- 输出数据应当存放在内存的 `x3101` 处。

## 输入输出样例

如果输入是 `6`（内存的 `x3100` 处），输出应当是：

```
8
```

这是因为：

```
6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
```

总共有 8 步，不算开始的数字 6，但算上最后的数字 1。

## 详细要求

- 使用 **LC-3 汇编** 完成程序。
  
  - 比如 `LDI R0, INPUT`。
  
  - 我们非常希望你能够根据“代码风格”一节中提到的内容调整你的代码格式。规范的代码格式不仅更易读，也能避免一些潜在的错误或漏洞。

- 你的程序会被装载到 `x3000`。
  
  - 后续的实验 3 到实验 5 也是一样。（以后我可是不会再提醒了！）

- **一定要**用 `HALT` 来停止你的程序，就像你用 `return 0;` 来结束你的 C 程序一样。
  
  - 如果你不这么做，评测姬会抛出一个**运行错误**，而且不会让你拿到 AC。LC3Tools 也同样会抛出异常。

- 输入数据保证小于 100，并且至少是 2。

- 不要抄代码，否则**后果很严重**！

## 指南

### 除法可不是小学内容

把一个数乘 2 简直是有手就行：

```
ADD R0, R0, R0
```

但是除以 2 呢？LC-3 并没有 `DIV` 或者 `SHR` 指令，而要实现它们也并非易事。我们有两种解决方案，一种比较暴力，另一种更快（但是代码会更复杂）。

#### 暴力解法：尝试与错误

最简单的办法就是一个一个试。首先把一个寄存器设置为 0，把它乘 2（放在另一个寄存器中），看看结果是不是被除数。不是？那么把它加上 1，然后再试一次。还不是？继续，直到你找到正确答案。

这种办法需要多久呢？LC-3 中最大的有符号数是 32767，所以你**最多需要尝试 16383 次**（平均是 8192 次），还不算太糟糕。不过，仅仅是一个除法就要试 8192 次，这未免有点……不太优雅。我们有没有更好的办法呢？

也许吧。

#### 优美解法：逐位测试

把一个数除以 2 也就是把它**向右移一位**。我们可以检测每一位上的数，然后根据检测结果构造它右移后的结果。具体方法如下：

1. 使用 2 个寄存器：`R0 = 1` 和 `R1 = 2`。我们用 `R1` 来进行检测，而 `R0` 始终存储着 `R1` 的一半，也就是 `R1` 右移后的结果。

2. 把被除数与 `R1` 进行 `AND`。这会提取被除数中相应的位，就像作业 1 中那样。

3. 用 `BRz` 进行分支：
   
   - 如果结果不是 0，那么相应的位是 `1`，由于 `R0` 存储的是 `R1` 右移后的结果，因此我们只需要将 `R0` 添加到结果中。
   
   - 如果结果是 0，那么相应的位是 `0`，我们跳过这一位。

4. 将 `R0` 和 `R1` 都左移一位（这样 `R0` 还是 `R1` 右移一位后的结果）。

5. 重复以上操作，直到测试完全部 15 位（最低位不用测试）。

> 例如，被除数是 `01001000` 时：
> 
> 1. 初始化 `R0 = 00000001, R1 = 00000010`.
> 
> 2. `01001000 AND 00000010 (R1)` 是 `0`，跳过这一位，将 `R1` 和 `R0` 分别左移一位（`R0 = 00000010, R1 = 00000100`）。
> 
> 3. `01001000 AND 00000100 (R1)` 是 `0`，跳过这一位，将 `R1` 和 `R0` 分别左移一位（`R0 = 00000100, R1 = 00001000`）。
> 
> 4. `01001000 AND 00001000 (R1)` 是 `1`，于是将 `00000100 (R0)` 加入结果，并将 `R1` 和 `R0` 继续左移。
> 
> ……继续这么做，最后你就会得到 `00100100`，正是 `01001000` 除以 2 后的结果。

这个方法快多了，因为我们只需要测试 15 次，比第一种方法**快 500 倍**！这样的差别可能在 LC3Tools 中看不出来，但如果你运行程序很多遍，优化的效果还是立竿见影的。

### 指哪打哪

如果你想读写某块内存，但是它并没有标签，那么你可以通过使用 `LDI` 和 `STI` 来做到：

```
LDI R0, INPUT       ; 把 x3100 中的值读入 R0
STI R0, OUTPUT      ; 把 R0 中的值写入  x3101

; 更多...

INPUT  .FILL x3100
OUTPUT .FILL x3101
```

但是要小心这里的一个坑点：**不要把数据当指令执行**。`x3100` 作为地址完全合理合规，但作为指令就不那么……合理了（它解释成 `JMP R0`，如果你很感兴趣的话）。我知道你会说“我堂堂 USTCer 计科糕手，就是西内，从这里跳下去，也不会把数据当指令执行的！”，并且我也很相信你，但是事情出错的地方**常常不在我们的考虑范围内**。比如：

```
LDI R0, INPUT
INPUT .FILL x3100
; More...
```

LC-3 按顺序执行每一条指令，它首先执行 `LDI`，然后继续向前迈进，它不知道 `x3100` **并不是一条指令** —— 它不在乎，因为冯·诺伊曼架构**本就该如此工作**。你知道 `x3100` 是一个地址，是因为你是从汇编的视角看待程序的，但对于 LC-3，它只看到了 `x3100`。LC-3 会把 `x3100` 解释为 `JMP R0` 并执行，然后事情很快就变成了一团糟。

我们不能容许 PC 挪到 `INPUT` 那里，因此我们需要使用下面的两个措施之一：

1. 用分支跳过数据区域：
   
   ```
   BR   SKIP_DATA
   
   INPUT  .FILL x3100
   OUTPUT .FILL x3101
   
   SKIP_DATA
   ; 更多...
   ```

2. 把数据挪到 `HALT` 后面，确保程序永远到不了那里：
   
   ```
   ; 更多...
   HALT
   
   INPUT  .FILL x3100
   OUTPUT .FILL x3101
   ```

你可以选择你喜欢的方式，不过我个人建议使用第二种，因为它清晰地将数据和指令区分开来，还能减少不必要的分支指令。

### 声明一个 LC-3 程序

一个有效的 LC-3 程序应当以 `.ORIG` 伪指令开始，以 `.END` 伪指令结束，就像这样：

```
.ORIG x3000
; ...指令
.END
```

`.ORIG` 以及它之后的数字告诉 LC-3 **在哪里加载你的代码**。由于你的代码被加载到 `x3000`，因此你需要声明 `.ORIG x3000`。

`.END` 告诉汇编器程序在这里结束。注意，`.END` 本身**什么也不做**，它只存在于汇编代码中，当汇编完成后，`.END` 就不复存在。

?> 要注意区分**停止程序**（`HALT`）和**程序结束标记**（`.END`）的区别。

### 清零寄存器

LC-3 中的寄存器在机器启动时，其中的值是随机的。考虑到这一点，在使用寄存器前需要对它们清零。以 `R0` 为例：

```
AND R0, R0, x0
```

如果你的程序表现得很诡异，那么请在调试时考虑到“寄存器有没有清零？”这一点。

## 提示和技巧

- 如果你觉得优美地进行除法太难了，不妨试试暴力求解。

- `BRnzp` 可以被简写为 `BR`。

- **不要忘记把计算结果存入指定的内存位置**。这看上去是废话，但是当你写完了一个很复杂的算法后，你很容易漏掉这样的细节。

- 虽然不做要求，但这个程序确实可以在 40 行代码内完成，即便是使用更复杂的按位检测除法。

- 不要把数据当指令执行了。如果你的程序行为很诡异，请检查一下这一点。（LC3XT 应该也会在运行的时候给出警告，但我们无法保证这一点）

## 代码风格

整洁而清晰的代码风格可以让你的代码更容易阅读和修改，并且更加健壮。我们并不强制要求使用哪一种特定的代码风格，不过如果你想变强，你可以参考下述的内容来构建你自己的代码风格：

1. 一行一条指令：
   
   ```
   ADD R0, R0, x0 AND R0, R0, xa BRn GOTO  ; ❌ 淦！
   
   ADD R0, R0, x0                          ; ✅ 帅！
   AND R0, R0, xa                          ; ✅ 帅！
   BRn GOTO                                ; ✅ 帅！
   ```
   
   理由：将指令分行写可以让程序结构更清晰。

2. 指令和寄存器名采取大写：
   
   ```
   and r0, r0    ; ❌ 淦！
   AND R0, R0    ; ✅ 帅！
   ```
   
   理由：大写字母的高度相同，让代码看上去不那么乱。

3. 将操作数和指令对齐：
   
   ```
   LD R0, LABEL      ; ❌ 淦！
   LDR R0, R6, x1    ; ❌ 淦！
   
   LD  R0, LABEL     ; ✅ 帅！
   LDR R0, R6, x1    ; ✅ 帅！
   ```
   
   理由：对齐的指令看上去更整齐，并且很容易修改。

4. 在逗号 `,` 后留下空格:
   
   ```
   AND R1,R2,R3      ; ❌ 淦！
   AND R1, R2, R3    ; ✅ 帅！
   ```
   
   理由：空格能让操作数彼此之间不那么贴近，更容易辨识它们。

5. 在立即数之前使用 `#`（十进制）或小写的 `x`（十六进制）：
   
   ```
   ADD R0, R0, 1    ; ❌ 淦！
   ADD R0, R0, X1   ; ❌ 淦！
   
   ADD R0, R0, #1   ; ✅ 帅！
   ADD R0, R0, x1   ; ✅ 帅！
   ```
   
   理由：立即数的前缀是 LC-3 的规范要求，而小写的 `x` 能让立即数更显眼。

6. 使用有意义的注释和标签:
   
   ```
   ; 原始人，启动！                     ; ❌ 淦！
   LEA R0, 这不是一个标签               ; ❌ 淦！
   
   ; 加载入口点地址                     ; ✅ 帅！
   LEA R0, 程序地址                    ; ✅ 帅！
   ```
   
   ?> LC3Tools 可能无法支持含有中文的标签，并且我们也不推荐这样做。上述的例子仅仅是为了凸显合理命名的重要性。
   
   理由：合理命名的注释和标签让你能够理解它们的含义。

7. 将标签放在指令的左侧或上方，并且将它们对齐：
   
   ```
   LABEL AND R0, R0, x0    ; ❌ 淦！
   ADD R0, R0, xf          ; ❌ 淦！
   
   LABEL AND R0, R0, x0    ; ✅ 帅！
         ADD R0, R0, xf    ; ✅ 帅！
   
   LABEL                   
   AND R0, R0, x0          ; ✅ 帅！
   ADD R0, R0, xf          ; ✅ 帅！
   ```
   
   理由：排列整齐的标签和指令更易读。

8. 在合适的地方加上空行：
   
   ```
   LABEL               ; ❌ 淦！
   ADD R1, R0, R0      ; ❌ 淦！
   LABEL2              ; ❌ 淦！
   ADD R0, R1, R0      ; ❌ 淦！
   
   LABEL               ; ✅ 帅！
   ADD R1, R0, R0      ; ✅ 帅！
                       ; ✅ 帅！
   LABEL2              ; ✅ 帅！
   ADD R0, R1, R0      ; ✅ 帅！
   ```
   
   理由：合适的空行能区分程序的不同部分。

要注意的是，上述的这些规范只是**参考**，甚至都不能称之为一种建议。**适合你自己的代码风格才是最好的**，我们希望你能基于这个范例，构建出属于自己的代码风格。

## 实验报告

报告要求和实验 1 相同。

## 提交

提交要求和实验 1 相同，但如果你在使用 LC3XT，那么这次记得要使用**汇编语言**完成评测。如果你只使用 LC3Tools 并且打算手动提交代码，请附上汇编代码文件。
