# 实验 4：未雨绸缪

*注：中文版为阅读理解方便而编写，与原文有所不同，请**务必同时参考英文原文**。*

## 概述

> 比起执着于变幻莫测的未来，不如将砖石垒在当下。

终于从回文的轮回中逃出来了？和那一样的是，我们的实验也算到了个重要的转折点。半程已过，去路方长；不忘初心，方得始终。或许你已经开始厌倦于汇编语言的繁杂与琐碎，但请不要丧失探究新事物的热情。保持惊奇，不言放弃，“若能在过去探寻现在，便能从现在把握未来”。

## 背景

下面的故事，或许你在哪里读过：

Sakiko 是一个富裕家庭的千金……本该如此的。由于家庭遭遇了某种变故，她的父亲日益消沉，而且开始酗酒。Sakiko 需要为家庭寻求额外的经济支持。每个月，她能通过工作收入一部分金钱，而她的父亲则会花费一点……或者亿点。

为了不至于囊中羞涩，Sakiko 制定了一个储蓄计划，她整理了一下已知的信息：

> - 一开始拥有 10 元。
> 
> - 第一个月的收入是 6 元，此后每月翻倍。
> 
> - 第一个月的支出是 2 元，此后每月变为 4 倍（这是很多！），但是……
> 
> - 如果支出超过本月的收入，则下月的支出恢复到 2 元。

那么，在几个月后，Sakiko 能拥有多少钱？

## 任务目标

计算在 `N` 个月后，Sakiko 能拥有多少存款。

- 必须使用**自顶向下**的方法，即使用递归的方式计算收入和支出。

- 输入数据 `N` 位于 `x3100`。

- 输出数据应当存放在 `x3200`。

- `N` 不会超过 `10`。

## 输入输出样例

输入（位于 `x3100`）：

```
3
```

输出（位于 `x3200`）：

```
10
```

## 详细要求

- 所有寄存器在评测前已经为你清零（仅限本次实验）。

- `N` 可能是 `0`，但不会为负数。

## 指南

### 调用函数

LC-3 内置了调用子程序并返回的功能：

```
JSR FOO
AND R0, R0, x0
ADD R0, R0, x5
JSR FOO
; R0 = 10 (xa)

HALT

FOO
ADD R0, R0, R0
RET
```

但是，对于更一般的情况，例如下面的 C 程序：

```c
int fib(int i) {
    if (i == 1 || i == 2) return 0;
    return fib(i - 1) + fib(i - 2);
}
```

在 LC-3 中是**不会**正常工作的，因为子程序可能会**改变寄存器的值**。在上面的例子中，就拿 `i` 作为代表，当调用 `fib(i - 1)` 返回时，`i` 的值可能已经发生了变化，那么 `fib(i - 2)` 的结果也就不再正确了。

要避免这样的情况，在调用函数和返回后都必须相应地**存储和恢复**寄存器的值：

1. 调用函数前，调用者将各个寄存器的值**压入栈**。

2. 执行函数调用，并等待它返回。

3. 函数返回后，从栈中**弹出**先前备份的值，并还原到寄存器中。

如果除了函数调用外没有其它地方修改栈的内容，那么由于存储和恢复操作是配对的，因此在函数返回后，我们能确保**从栈中弹出的值就是先前存储的寄存器的值**。

---

要实现一个栈也非常容易：

1. 选择一个地址（通常是 `x6000`）作为栈顶。

2. 压入栈：将数据写入栈顶所在位置，然后将栈顶**向左移动**（减少）。

3. 弹出栈：从栈顶读出数据，然后将栈顶**向右移动**（增加）。

如果 `R6` 是栈指针，那么下面是压入和弹出 `R0` 的 代码：

```
; PUSH
STR R0, R6, x0
ADD R6, R6, x-1

; POP
ADD R6, R6, x1
LDR R0, R6, x0
```

这就 OK 了！通过存储和恢复寄存器的值，函数内部的局部变量就能在递归调用中维持不变。

## 模板

使用下面的模板可以些微减少你准备实验的时间：

```
.ORIG x3000

LDI R0, INPUT

; ...

STACK .FILL x6000
INPUT .FILL x3100
RESULT .FILL x3200

.END
```

## 技巧和提示

- 必须存储和恢复寄存器，特别是 `R7`，否则程序不会返回到正确的地方。

- 请注意，`STR` **有 3 个操作数**。

- `STACK` 标签中的值 `x6000` 是栈顶指针的**初始值**。一般我们将**当前的栈顶指针**存储在 `R6` 中。

## 实验报告

实验报告的要求与实验 1 相同。

## 提交

提交要求与实验 2 相同。
