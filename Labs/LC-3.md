# LC-3 汇编语法

## Hello World

以下是 LC-3 版本的 Hello World 程序，这有助于你了解基本的语法：

```
.ORIG x3000

LEA R0, TEXT
PUTS
HALT

TEXT .STRINGZ "hello, world"
.END
```

如果你运行该程序，程序将输出 `hello, world`。

?> 你可以在 LC3XT 中测试该程序，只需要选择“环境测试”即可。

## 概述

一个 LC-3 程序是由多条**指令（Instruction）**组成的，每条指令能执行一个基本的操作。与 C 不同，汇编中没有块，也没有语句和运算符等概念，只包含有指令。

一条指令的语法如下：

```
[标签] <操作符> [操作数[,操作数[,操作数]]]
```

?> 语法表述中的中括号 `[]` 代表可选，尖括号 `<>` 代表必需，中括号和尖括号本身**并不是语法的一部分**。正确的指令形如 `LABEL AND R0, R0, x0` 而非 `[LABEL] <AND> [R0[,R0[,R0]]]`。

## LC3Tools 和 LC3XT

你可以选用 LC3Tools 或 LC3XT 来汇编你的程序，二者的功能和所接受的语法非常相似，但在细节上可能略有差距。大体来说，LC3XT 比 LC3Tools 在语法上更加宽松，但在执行上更加严格。这些差异会在文中标注。

## 指令和伪指令

LC-3 中的指令有两种：

- 一般指令：在程序**运行**时执行的指令，例如 `ADD R0, R0, x1` 指示 LC-3 在执行时对 `R0` 增加 `1`。

- 伪指令：在程序**汇编**时执行的指令，例如 `.FILL x3101` 在当前的位置填入 `x3101`，在程序运行时，LC-3 将只会看到 `x3101`，并将它解释为 `ST R0, #-255`。

?> 伪指令在运行时不可见，但不代表它们不会影响程序的执行。伪指令通常用于在程序中填入各类数据，这些数据将是程序运行所必需的。

为了规范起见，伪指令的名称都以 `.` 开头。

## 立即数

在 LC-3 中，要使用一个数字常量，需要使用如下的语法：

```
x<十六进制表示>
#<十进制表示>
```

例如，`xa` 代表数字 `10`，而 `#-1` 代表数字 `-1`。

?> 在使用立即数时，要注意是否超出那条指令所能表示的范围。例如，`ADD R0, R0, <IMM>` 中的立即数 `IMM` 只有 5 位，因此只能表示 `-16` 至 `15` 范围内的数字。如果你尝试写出 `ADD R0, R0, x10` 这样的指令，就会发生汇编错误。

## 程序的划分

你已经知道，程序在运行时被**装载**到内存中，随后 LC-3 从一个指定的地址开始执行程序。汇编程序的本质是**在内存的指定位置填入指令或数据**。因此，一个汇编程序可以只包含一段程序，也可以包含多个（填入内存的不同位置）。为了分隔这些程序，就需要使用 `.ORIG` 和 `.END`。

一个**程序段**指的是连续填入内存某块区域的一列指令或数据，定义一个程序段的语法如下：

```
.ORIG <起始地址>
.END
```

起始地址是一个 16 位无符号立即数，最常见的是 `x3000`，但有时也会需要使用另外的地址。

> **为什么是 `x3000`？**
> 
> LC-3 在机器上电时（模拟器启动时）处于管理模式，并且会从 `x0200` 开始执行指令，`x0200` 那里的程序会切换到用户模式并跳转到 `x3000`，从而启动用户程序。这就像 C 语言中的 `main` 函数一样 —— 这是一种**约定**。

指令只能定义在一对 `.ORIG` 和 `.END` 之间。`.ORIG` **形式地**标记程序的开始，而 `.END` **形式地**标记程序的结束（记住这个，等会要考）。

## 定义一般指令

在划分程序后，就可以在对应的段内定义指令。一般指令的定义是先写出操作符，然后再在后方跟上所需的操作数，并以逗号 `,` 分隔。例如：

```
AND R0, R0, x0
ADD R0, R0, xa
ADD R0, R0, R0
```

注意：

- LC-3 不区分大小写，你可以选择你喜欢的形式 —— 但是代码样式最好保持一致（要么全部大写，要么全部小写，而不要写成 `aNd` 这种格式）。

- 操作符和操作数之间须至少包含一个空格，而且不含逗号 `,`。

- 一行只能（LC3Tools）/ 建议（LC3XT）包含一条指令。相对应的，一条指令只能（LC3Tools）/ 建议（LC3XT）写在一行当中。

一般指令的具体功能请参考教材的附录 A（第 656 页）。

## 注释

合理使用注释分隔程序的不同部分，并对指令进行解释。

注释以分号 `;` 开头，并持续到当前行结束：

```
ADD R0, R0, x0    ; 这是注释
```

## 使用标签

在一条指令前加上标签，就可以标记这条指令的地址，随后就可以在各类指令中使用。

```
MY_LABEL ADD R0, R0, x0  ; 定义标签
; ...
BR MY_LABEL              ; 使用标签
```

LC-3 中的标签不区分（LC3Tools）/ 区分（LC3XT）大小写。

标签可以用于以下用途：

- `BR` 指令：当条件满足时，程序将跳转到标签所对应地址的指令。

- `LD` 指令：程序将从标签对应的地址中读取数据。

- `LDI` 指令：程序将从标签对应的地址中读出数据，然后将该数据作为地址再次访问内存，从对应地址上读出数据。

- `ST` 指令：程序将把数据写入标签对应的地址。

- `STI` 指令：程序将从标签对应的地址中读出数据，然后将该数据作为地址再次访问内存，向对应地址上写入数据。

- `LEA` 指令：程序将标签的地址写入对应的寄存器。

标签可以加注在指令前，也可以分行写在指令上方，以下两种都是正确的：

```
LABEL_1
ADD R0, R0, x0

LABEL_1 ADD R0, R0, x0
```

一条指令可以有多个标签，但是一行内仍然最多只能包含一个标签（LC3Tools）/ 并且可以将多个标签写在一行内（LC3XT）。

## 伪指令

LC-3 中有一些伪指令，可以实现特定的功能：

### `.ORIG`

```
.ORIG x3000
```

标记一段程序的起点。

### `.END`

```
.END
```

标记一段程序的终点。

### `.FILL`

```
.FILL x1
```

在当前的位置填入所指定的立即数（该地址上不再放置指令）。

下一条指令会从当前地址之后开始填入。

在 LC3Tools 中 `.FILL` 对于数字的解释比较特殊：如果该立即数是负数，则解释为有符号数并填入其补码；如果是正数，则解释为无符号数。所以 `.FILL x-1` 和 `.FILL xffff` 填入的内容相同，并且都能通过汇编。

在 LC3XT 中，`.FILL` 后的数字始终解释为有符号数。

通常 `.FILL` 会与标签一同使用，以便于访问所定义的立即数。

### `.BLKW`

```
.BLKW 10
```

从当前位置开始，连续留出指定数目的空间，并为其填入 `0`。

?> `.BLKW` 后的数字可以不加 `x` 或 `#` 作为前缀，这是唯一的特例。如果没有前缀，则按十进制解释。

下一条指令将从这些留空的空间之后开始填入。

通常 `.BLKW` 会与标签一同使用，以便于访问所留出的空间。

### `.STRINGZ`

```
.STRINGZ "ciallo, world"
```

从当前位置开始，连续填入指定的字符串当中的字符，每个地址上填入所对应字符的 ASCII 编码，并在最后额外添加一个 `0`。

字符串可以不包含双引号 `"`（LC3Tools）/ 必须以双引号 `"` 包裹（LC3XT）。

下一条指令将从最后填入的那个 `0` 之后开始填入。

通常 `.STRINGZ` 会与标签一同使用，以便于访问所填入的字符串。

## 终止程序

在程序执行完成后，必须使用 `HALT` 来让 LC-3 **停机**。

?> 有别于形式上的 `.END`，`.END` 只是宣告“程序的内容到此为止了”，但**不会让 LC-3 真正停下来**。要让 LC-3 停止，必须使用 `HALT`，否则程序会在本该停止的位置继续向后执行，造成不可预料的后果（LC3Tools）/ 引发内存访问错误（LC3XT）。

## 常用代码片段

下面的这些片段实现了一些常用的功能，你可以用它们来构建你的程序：

### 清零寄存器

寄存器在机器启动时的值是零（`R6` 除外）（LC3Tools）/ 随机的（LC3XT），因此需要对寄存器清零。

常用的清零方法是与 `0` 进行与运算，下面的代码对 `R0` 清零：

```
AND R0, R0, x0
```

### 加载数据到寄存器中

下面的代码加载 `LABEL` 所对应的数据到 `R0` 中：

```
LD R0, LABEL
; ...
LABEL .FILL x1234
```

注意，`LABEL` 和 `.FILL` 必须放在所无法执行到的位置，即程序的最后（`HALT` 以后），或者用 `BR` 跳过这些数据。

?> 小于 5 位的立即数也可以通过清零和 `ADD` 指令填入寄存器。

### 自增

下面的代码自增 `R0`：

```
ADD R0, R0, x1
```

### 条件分支

下面的代码在 `R0` 中的值是 `0` 时执行分支 2，否则执行分支 1：

```
ADD R0, R0, x0
BRz BRANCH_2

; ======
; 分支 1
; ======

BR BRANCH_END

BRANCH_2

; ======
; 分支 2
; ======

BRANCH_END

; 后续
```

有些指令在运算时就已经设置了条件码，那么就不必在像本程序中那样使用 `ADD` 来判别 `R0` 的正负。

### 比大小

下面的代码比较 `R0` 和 `R1` 的大小，并将结果存储在 `R2` 中，`R2` 的正负性指示了比大小的结果。由于比大小实质上是减法，因此 `R2` 中存储的是 `R0 - R1` 的结果。

```
NOT R1, R1
ADD R1, R1, x1
ADD R2, R0, R1
ADD R1, R1, x-1
NOT R1, R1
```

本程序的执行除 `R2` 外不影响任何寄存器的值。

### 循环

下面的代码循环对 `R0` 自增，直到 `R0` 大于 `0`：

```
AND R0, R0, x0
ADD R0, R0, x-a

LOOP
ADD R0, R0, x1
BRnz LOOP
```

### 过程调用

下面的代码调用过程 `FOO`，以对 `R0` 乘 2：

```
AND R0, R0, x0
ADD R0, R0, x2
JSR FOO

; ...

FOO
ADD R0, R0, R0
RET
```

注意，为了不让程序直接执行过程 `FOO`（而是通过 `JSR` 来执行），必须和数据一样，将 `FOO` 放在程序所执行不到的位置。
