# 终极实验 A：汇编器

## 命运所指

> 抉择就在眼前，结局早已注定。

从 1 和 0 构成的机器代码，到标签和指令的世界，经历中断等等波折，再到熟悉而又陌生的 C 语言，不断的讲述和练习，计算系统庞大的结构在你的脑海中不断延伸，由朦胧的概念逐渐形成了似真似幻的构想，再演化成尤为清晰的形象。一切看似都已经趋近完美，只要**在这里停下**，为这个系列画上句号，你就可以从实验中“安全下车”，故事也将抵达它的尾页。你 ——

<style>
    .btn {
        background-color: rgba(255, 180, 220, 0);
        width: 80%; 
        border: 2px solid; 
        border-color: rgb(255, 154, 187, 0.7); 
        border-radius: 5px;
        color: inherit; 
        text-align: center;
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
        font-weight: bold;
        font-size: 1rem;
        transition: 200ms;
        cursor: pointer;
    }

    .btn:hover {
        border-color: #fff0b3;
        box-shadow: 0px 0px 10px #fff0b3;
    }
</style>

<script>


function acceptThat() {
    document.querySelectorAll("button.btn").forEach(e=>e.parentNode.remove());
    document.getElementById("t-accept").style.display = "initial";
    sessionStorage.setItem("op.final", "accept")
}

function rejectThat() {
    document.querySelectorAll("button.btn").forEach(e=>e.parentNode.remove());
    document.getElementById("t-reject").style.display = "initial";
    sessionStorage.setItem("op.final", "reject")
}

window.acceptThat = acceptThat
window.rejectThat = rejectThat
window.finalOp = sessionStorage.getItem("op.final")

if(window.finalOp == "accept") acceptThat()
if(window.finalOp == "reject") rejectThat()
</script>

<div style="display: flex; justify-content: center; width: 100%; margin-top: 3rem;">
<button class="btn" onclick="acceptThat()">
接受这个命运
</button>
</div>

<div style="display: flex; justify-content: center; width: 100%; margin-top: 2rem; margin-bottom: 3rem;">
<button class="btn" onclick="rejectThat()">
不接受这个命运
</button>
</div>

<script>

</script>

<div style="display: none;" id="t-accept">

**接受这个命运。**

> 岁久人无千日好，春深花有几时红？

尾页已至，作家放下手中的笔，将结尾留给读者自作想象。在这里结束，倒也不失为一桩美谈。翻过封底，故事看似已然圆满，今后的事，你我都已知晓。

[退出至首页](/Labs/README)

</div>

<div style="display: none;" id="t-reject">

**不接受这个命运。**

> 莫嫌举世无知己，未有庸人不忌才。

描绘的画笔不曾停歇，构想的修辞流淌不竭，作家正将故事引上另一条路。有人欣喜，期待着尾页上的新章节；有人畏惧，担忧这临门一脚的变数。今后的事，我们尚不可知。

## 背景

每一行代码都诉说着你的构想，那些构想组成了新的篇章。只要按下“汇编”按钮，就能将构想即刻变成现实。但为什么呢？你将视线投向汇编代码的身后，名为**汇编器**的程序 —— LC3XT Loli，正在尽职尽责地将每一条指令翻译成机器能够理解的语言。在过去如此，在那个“到此为止”的分支也是如此。可是，你打破了既有的计划，开辟了一条新路线。在这个故事里，Loli 并不存在。为了编织这段新的故事，你必须**亲自讲述**，亲自将你的构想描绘为现实。

## 任务目标

设计、创建、测试并部署一个 LC-3 汇编器。

- 对于每一段语法合规的汇编代码，你的汇编器需要正确生成汇编代码。

- 对于存在错误的程序，不做任何要求。汇编器可以报告错误，也可以在缺少数据的情况下尝试完成汇编。

## 规范的 LC-3 语法

在本实验中，所使用的 LC-3 语法为规范语法，满足以下条件：

- 每行只能包含以下四种内容之一：
  
  - 空白符（空格、制表符、换行符等）
  
  - 单一的标签
  
  - 不带标签的指令
  
  - 带有一个标签的指令

- 指令不会分拆到多行中。

- 操作码和操作数的大小写**可能不定**。

- 操作数之间均以逗号 `,` 分隔，**可能不含空格**。

- `.BLKW` 将不会使用带有前缀的立即数。

- 标签可以包含**连续的任意多个非空白字符**。

- 分号可能出现在字符串内，此时**不将其视为注释**。

除语法的规范外，汇编程序也保证所使用到的资源符合 LC-3 机器的限制，包括寄存器编号和立即数范围。

## 快速开始

实现一个具备诊断功能的、宽容的汇编器是很困难的，即便是只解析规范的程序，要编写相应的程序也是不容易的。你可以选择从头开始，自行设计和构建程序，但这有些麻烦，特别是如果你还不知道如何进行软件工程中的常见操作，如单元测试等。幸运的是，你并不需要具备相关的知识（至少不是必须现在）就能完成这个项目，只需要使用我们提供的**快速开始模板（Quick Start Boilerplate）**。

?> 虽然模板常被称为**框架（Framework）**，但二者有本质上的区别。框架通常是作为单独的软件包发行的，你可以在自己的项目中使用框架来构建程序。相对应的，模板已经提供了部分代码，而你只需要进行一些补全工作。

我们针对一些语言，提供以下的模板，它们各使用不同的技术栈，优缺点也不尽相同，你可以从中任选一个来完成这个项目：

- Kotlin（代码最简单）
  
  这个基于 Kotlin 和 JVM 的模板能让你以最舒适的方式完成这个汇编器，并享受到业界领先编程语言的性能与便利。

- TypeScript 和 JavaScript（收获最大）
  
  这个基于 Node.js 的模板是经由 Loli 的源代码裁剪而来的，以便于你了解 JavaScript 这样一门适用于各个领域的语言。

- Python（最容易配置）
  
  这个基于 Python 的模板精简而灵活，并且不需要太多的配置就能开始使用。

- C 和 C++（最经典）
  
  这个基于 C++ 的模板保留了该实验传统的风格，旨在向有挑战精神的读者展示经典的程序设计艺术。

?> 如果你不确定要使用哪个模板，推荐你使用 Kotlin，Kotlin 模板所需的代码量最少，调试起来最容易，并且我们已经为这门语言准备了配套的教学（请参见左侧的导航栏）。

这些模板的结构大致相似，但在细节上却又有差距，在选用你的模板后，请先阅读它的文档。

## 构造汇编器的方法

### 概览

在学习 C 语言的时候你已经知道，源代码不能为机器所直接执行，它必须经过一系列操作“转换”为机器代码，装载到内存中才能运行。对于一般的高级编程语言，生成机器代码（很大程度上是目标文件）的操作称为**编译（Compile）**，而对于 LC-3，相应的程序也就称为**汇编（Assemble）**。虽然称呼不同，但二者所作的工作是类似的。

在 LC-3 汇编语言转换到机器代码的过程中，有以下几个主要步骤：

- **词法分析（Tokenizing）**：将代码的基本单元进行识别和转换，例如将 `R0` 识别为“寄存器”，`x3100` 识别为“立即数”，`AND` 识别为“操作码”等。源代码由此被转换为一列**符号（Token）**。注释的删除和字符串的识别在这一步完成。

- **语法分析（Parsing）**：按照语法规则组合符号，形成基本的表达式或语句。在 LC-3 中，通常是先读取操作码，然后根据操作码读取指定个数的操作数。例如，语法分析器读取到 `NOT`，它知道 `NOT` 需要 2 个操作数，于是在符号列表中继续向后搜寻，读取两个符号（例如 `R1`、`R2`），并将它们与 `NOT` 合并在一起，组成一条指令。标签的标识在这一步完成。

- **链接（Linking）**：根据由 `.ORIG` 指定的程序开始地址，计算每条指令在内存中的位置，并由此计算出每个标签对应的地址。

- **代码生成（Generating）**：依据标签地址表和组合好的指令，根据编码规则，生成最终的机器代码。

除了这些主要步骤之外，还有一些额外的辅助过程，例如读写文件等。我们将在下面的部分逐一介绍。

### 旅行的开始

汇编过程由**读入源代码**开始。源代码的读入有很多方式：文件、控制台键入、从 UI 控件读取等。我们为大多数代码框架都编写了**图形化界面**，也就是说，在做完后，你的程序会显示一个窗口，你可以在其中键入汇编代码，而汇编的结果会同时显示。不过，不管使用哪种方式读入源代码，最终你会得到一个**字符串**，这就是一切的开始。

```kotlin
val s: String = "..."
```

（在下文中，需要以代码辅助说明的地方，均采用 Kotlin 为例）

### 辨字与组词

要解析源代码，我们需要从字符串的开始，逐个读入字符，并**确定它属于哪种符号**（寄存器？立即数？标签？）。然而，尝试直接将读入的字符转换到最终的符号是很困难的，举个例子来说明：

- 读取到字符 `R`，看上去有点像寄存器，是这样吗？也许**不一定**。它也许是 `RET` 的一部分，或者是名为 `RESET` 的标签的一部分，必须继续向下读取。

- 假设下一个字符是 `0`，这下看上去应该是寄存器了？不，还是**不一定**。也许它只是名为 `R0_CLEAR` 的标签的一部分？还需要继续向下读取。

- 假设下一个字符是 `_`，这下终于可以确定它必定是标签了，你可以继续向后读取，直到读到一个空白符，这样已经读取的部分就构成一个标签。

这就是 LC-3 语法的问题 —— 仅通过读取下一个字符，无法判断当前符号的类型，在这种情况下，要处理识别这些符号的逻辑是相当困难的。

---

我们可以将 LC-3 语法先做一些概括，将符号区分为以下几种基本形式：

- **词语（Word）**：可能作为标签或者标签的一部分的符号，包括寄存器、立即数、标签、操作码和数字（由 `.BLKW` 使用）。

- **空白符（Whitespace）**：用于分隔词语的空格、制表符、逗号等。

- **注释（Comment）**：以分号 `;` 开始，持续到当前行结束。

- **字符串（String）**：以双引号 `"` 包裹，并可能含有转义字符如 `\"`、`\n` 等。

做了这样的区分后，判断下一个字符属于哪个符号就是非常简单的：

- 空格、制表符、换行符、逗号等：属于**空白符**。

- 分号 `;`：属于**注释**。
  
  ?> 分号 `;` 虽然可以出现在字符串当中，但它不能作为字符串的第一个字符，只需要在读取字符串的时候一直向后移进，直到遇到另一个双引号，就可以正确处理字符串中的分号。

- 双引号 `"`：属于**字符串**。

- 其它符号：属于**词语**。

依据这样的特征，我们可以每次读取一个符号，并且将它划分为上述的四种类型之一。

---

对于空白符、双引号和注释，它们的含义我们已经明确。而对于词语，我们可以通过**正则表达式**来识别其所对应的含义。正则表达式是用于描述一类具有相同特征字符串的代码，尽管掌握了很有用，但如果你没有掌握正则表达式，也不必急着现在去学习，我们已经写好了相应的正则表达式：

- 寄存器：`R[0-7]`。即以字母 `R` 开头，同时后跟一个 `0` 至 `7` 的数字。

- 立即数：`x[+-]?[0-9A-F]+|#[+-]?[0-9]+`。即以 `x` 开头，后跟一个可选的正负号，再跟上多个十六进制数位；或以 `#` 开头，后跟正负号，再跟上多个十进制数位。

- 数字：仅由 `0` 至 `9` 构成的序列。

- 操作码：字符串与某个操作码完全相同。

- 标签：如果以上情况均不满足，那么该词语是一个标签。

---

做了这些识别之后，我们就成功将汇编源代码切分成多个符号，并且为每一个标注了它们的类型。采用上述这种方法构成的词法分析器，它的行为是**宽容的**。也就是说，它总是尽可能尝试理解源代码，而非提出错误。例如，我们并未区分分隔操作数用的逗号 `,` 以及分隔操作码和指令的空格，使得形如 `AND R0 R0 x0` 这样的指令同样可以通过汇编。这样的词法分析器能够允许源代码中一定的错误，但这并不完全是一件好事，更宽容的解析器能够让使用者构建程序时不必拘泥于语法细节，却有可能由于宽容性而“曲解”程序含义，以至于忽视了更为严重的错误。

原则上，分析器（不论是词法分析器还是下方要提到的语法分析器）应当严格地遵循规范，不允许有错误的程序通过检查，也不对正确的程序提出任何错误。然而，由于 LC-3 无论是词法上还是语法上都缺乏明确的规范，这一点很难做到。即便是对于词法语法规范都相当明确的语言，要实现一个完全严格的分析器也是非常困难的。为了了解这是何等的困难，读者可以自行尝试将实验中的分析器修改为严格的版本，并使用一些有微小错误的程序来进行检验。

### 构句与修饰

将源代码拆分为符号后，我们就能更进一步将符号组成**原指令（Raw Instruction）**，并进一步构成**指令（Instruction）**，这就是所谓的**语法分析**。原指令仅从形式上分析语法，它只负责为操作码匹配对应个数和类型的操作数，而不对这些操作数进行任何解析。当原指令构建完成后，将它们翻译到具体的指令就相当简单了。

一些汇编器采取**基于形式的分析**，即不管操作码究竟是什么，将其后所跟随的所有以逗号分隔的操作数全部归给当前的指令。这种方法在处理可能有多余或缺少操作数的源程序时很有用，但如果操作数存在类型错误，则可能必须到生成代码的时候才能发现。

我们的汇编器将采取**基于类型的分析**，例如我们已经事先知道 `LDI` 需要两个操作数，一个是寄存器，一个是标签；当读到 `LDI` 操作码时，我们只需要根据这个类型定义，从剩下的输入中读取一个寄存器符号，再读取一个标签符号，就完成了这条原指令的构建。使用这种方法，任何多余的、缺漏的或者错误的操作数都会第一时间被检出。而代价是，分析器在发现第一个错误后就会停止，以至于要排除程序中所有的错误，可能需要重复汇编很多次。

为了对每个操作码定义其参数类型，我们使用一种**类型字符串**来标识各种类型的符号，例如，`LDI` 指令的类型字符串是 `RL`，其中 `R` 表示寄存器，而 `L` 表示标签。在分析时，只需要根据字符串的长度，读取相同数目的符号，并判断各个符号是否与指定的类型匹配。

每当读取完一条指令后，我们继续向下读取，因为指令前可能含有标签，所以分析器一直移进，直至遇到一个操作码，此时已经读取的标签就构成该指令前方所标注的标签。这种方法可以处理多行的标签，亦可以处理一行内的多个标签，是 LC3XT 所使用的解析方法。

尽管不同的语言采用不同的方法建立操作码与类型的映射，但我们使用的类型字符串是相同的：

- `R`：寄存器

- `I`：立即数

- `L`：标签

- `A`：寄存器或立即数

- `N`：数字

- `S`：字符串

其中 `A` 的存在是为了支持 `AND` 这类既接受寄存器又接受立即数的指令，如果不增加这一类型，则必须修改分析器，代码会变得更复杂。



---

</div>
