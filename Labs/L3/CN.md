# 实验 3：双边检验

*注：中文版为阅读理解方便而编写，与原文有所不同，请**务必同时参考英文原文**。*

## 概述

> 横看成岭侧成峰，远近高低各不同。

用汇编语言来编写程序总算是比机器代码要简单了那么一丢丢吧（希望如此！）。啊，我明白，做点算术运算确实不算困难，但同时也一点乐趣都没有。那么，字符串呢？字符串很有趣，因为它能比数字更直观地表达很多东西，但同时也更难用程序处理（相对的）。如果你已经玩够了数列，那么抓好你的鼠标，准备迎接 —— 字符串的世界！

## 背景

来看看这些有趣的句子：

> - 上海自来水来自海上
> 
> - 风扇能扇风
> 
> - 中国藏宝玉，玉宝藏国中

先不管它们的含义如何，从**字面**上来看，你会发现不管是从左边还是从右边开始读（忽略标点符号），**读出的结果都是一样的**。这种句子被称为**回文句**。

“好吧，我承认回文是很有趣，但这和我数学物理大学有什么关系呢？”—— 就知道你会这样问。如果你对此还有些怀疑，那么有一个嚎消息要告诉你：你的英语老师刚刚布置了 10000 句不同的英文短语当作作业，而你要做的是判断它们中哪些是回文句。我猜你也不想把整个周末都花在读句子上，那么来得正好，你可以用 LC-3 来搞定这些句子，就像你先前在验证 Collatz 猜想中用它逃课一样。

## 任务目标

设计一个 LC-3 程序，判断给定的字符串是否为回文句。

- 字符串的长度（不含末尾的 `0`）会被填入 `x3100`。

- 字符串从 `x3101` 开始。
  
  - 第一个字母在 `x3101`，第二个在 `x3102`，以此类推。

- 程序的输出应当填入到 `x3200` 处。
  
  - 如果输入的句子是回文句，则填入 `1`，否则填入 `0`。

- 字符串只包含大小写英文字母，而且回文句的判断**不区分大小写**。

- 字符串最多只有 99 个字母。

- 如果输入字符串为空，则认为它是回文。

## 输入输出样例

输入：

- 长度（`x3100`）：3

- 内容（从 `x3101` 开始）：
  
  ```
  abc
  ```

输出（`x3200`）：

```
0
```

---

输入：

- 长度（`x3100`）：27

- 内容（从 `x3101` 开始）：
  
  ```
  siridemandiamamaidnamediris
  ```

输出（`x3200`）：

```
1
```

## 详细要求

- `R0` 至 `R7` 在程序开始前已经为你清零（仅限本次实验）。

- 与 C 语言不同，字符串**不保证以零字符结尾**。

- 字符串中的每个字母都需要清点。

- 无论句子中间是否有未配对的单个字母（例如 `aba` 和 `abba`），都将其视作回文。

- 输出值只能是 `0` 和 `1`，其它值会被判作无效。

## 指南

### 遍历字符串

想想你在 C 语言中曾做过的事情：要遍历（逐个访问）一个字符串，我们会做这些步骤：

0. 设置一个指针，指向字符串的第一个字符：
   
   ```
    str
     |
   | a | b | c | d | e |
   ```

1. 解引用指针，就能获得当前位置的字符：
   
   ```
    str
     |
   | a | b | c | d | e |
   
   ...读出 'a'
   ```

2. 把指针向右移动：
   
   ```
        str
         |
   | a | b | c | d | e |
   ```

3. 如果还没到达字符串的末尾，那就重复步骤 1 至 3。

用 C 来写的话就是这样：

```c
const char* str = "abc" // 字符串输入
int length = 3 // 字符串长度

for (int i = 0; i < length; i++) {
    char c = *str;
    // 使用读出的字符
    str++;
}
```

?> 当然你也可以使用形如 `str[i]` 的方法访问指定的字符，但在 LC-3 中这么做需要多一步加法，比较麻烦。

在 LC-3 中要做的事情也一样，我们用一个寄存器来存储指向我们想访问位置的指针，并用 `LDR` 指令读取数据。

另外提醒一下，`LDR` 接受三个操作数（目标寄存器，基址寄存器和偏移量）。

### 在本地测试

你当然可以通过手动编辑内存来填入字符串，但是这么做太麻烦了。有一种更简单的方法可以在测试时为你自动装载数据，你只需要创建两个程序段：

```
.ORIG x3000
; 程序主要代码
.END

.ORIG x3100
.FILL x5
.STRINGZ "abcba"
.END
```

两对 `.ORIG` 和 `.END` 创建了两个程序段，LC-3 会把它们分别装载到 `x3000` 和 `x3100`。在上述的例子里，`.FILL` 在“当前位置”（也就是 `x3100`，由 `.ORIG` 指定）填入 `x5`，然后 `.STRINGZ` 将 `abcba` 的每个字符逐个排列在它后面，从 `x3101` 到 `x3105`。

当你想修改测试数据的时候，只需要修改 `.FILL` 指定的字符串长度和 `.STRINGZ` 指定的字符串内容即可。

!> 在 LC3XT 中评测时，评测系统会自动填入数据，所以在提交前请确保**删除**第二段程序。

## 技巧和提示

- 如果你在上一次实验中已经有了自己的代码风格，那么请沿用它。否则，最好选择一个。

- 请**格外仔细地检查**边界条件（如什么时候退出循环等）。

- 不要忘了把输出存入 `x3200`。（以后我可是不会再提醒了！）

## 模板

你可以使用下面的模板代码来快速开始实验，只需要把它**复制粘贴**到编辑器中就 OK 啦！

```
.ORIG x3000

LDI R0, LENGTH
LD  R1, STRING

; 插入你的代码

HALT

LENGTH .FILL x3100
STRING .FILL x3101
RESULT .FILL x3200

.END

; 测试用的输入数据
; 在 LC3XT 上提交时，请一定要删除这部分

.ORIG x3100

.FILL #5            ; 字符串长
.STRINGZ "abcba"    ; 字符串内容

.END
```

当然，如果你觉得使用模板不太专业，那么也可以自行设计程序布局。

## 实验报告

继续按照实验 1 中的要求完成实验报告。

## 提交

提交的要求和实验 2 相同。
