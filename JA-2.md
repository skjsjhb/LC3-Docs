# JA-2 Java 流程控制

## 卷，卷死你们……

### 比大小问题

我们还是从一个很简单的表达式开始：

```java
3 > 2
```

啊，这是正确的，不是吗？我们比较了 `3` 和 `2`，`3` 确实大于 `2`。

不过等一下，这到底是个什么啊。你知道 `1 + 2` 的结果是**数字** `3`，但 `3 > 2` **本身**是什么呢？或者说，**比较**的结果是什么呢？

你心里可能已经有个答案了，比较的结果非黑即白非对即错，如果把“比较”这个过程本身看作一个算式，那它的结果就是一个**逻辑值**：“是的”，或者“不是”。

用专业的话来说：

**由比较运算符构成的表达式，其值是布尔（逻辑）值。**

也就是说， `3 > 2` 是一个**表达式**，就像其它的加法，减法，以及上一节中说到的比较特别的方法调用一样，它也可以被**计算**，计算的过程就是比较，而且**比较的结果**“对 `true` ”或者“错 `false`”成为**这个表达式自身的值**。

所以，我们可以说，**表达式 `3 > 2` 的值是 `true`。**

类似地：

```java
1.5 > 2.5
```

这个当然不对！所以，它的值是 `false`。

### 等于等于

```java
3 == 2
```

这里出现了两个等号 `==`，这代表“**相等吗？**”。由于一个等号 `=` 的写法已经在**给变量赋值**那里用掉了，为了不引起混乱，就用两个等号来比较数字是否相等。

很显然，`3` 和 `2` 不相等，所以表达式的结果是 `false`。

!> 在很多编辑器中，本来应当使用 `==` 的地方如果错误地使用了 `=`，由于也是完全符合语法的，编辑器（和编译器）并**不会报告任何错误**，但是赋值和比较是两种完全不同的东西，程序因此会产生非常奇怪的 bug，所以需要非常小心。

于是 Kirara 就写出这样的代码：

```java
"Ciallo~" == "Ciallo~"
```

> Kirara：哈哈，我是不是很聪明？快夸我快夸我！（抱住）

你个大聪明先从我身上下来……！好吧，也许不能怪她，即使是有经验的软件工程师，也偶尔会犯下这样的错误。`"Ciallo~"` 和 `"Ciallo~"` 在**内容上**确实是一样的，但如果直接用 `==` 来比较，Java 会给出 `false` 的结论，这个原因我们稍后再讲，现在你（和 Kirara）只需要记住：

**相等性比较运算符 `==` 只能用来比较数字以及布尔值。**

```java
true == false
```

“真的”不是“假的”，“黑”也不是“白”，所以上面这个表达式的值是 `false`。

```java
false == false
```

“假的”确实是“假的”，所以上面这个表达式的值是 `true`，尽管参与运算的两个元素都是 `false`，但它们**确实相等**，不是吗？

```java
3 > false
```

不行 —— **大于和小于（以及大于等于和小于等于）只能用来比较数字**。

```java
6 >= 5
```

大于等于和小于等于符号（`>=` 和 `<=`）可以直接使用。

```java
3 != 4
```

不等于符号 `!=` 用来判断两端的内容是否**不相等**，跟我念：`!` —— “不”，`=` —— “等于”，合在一起“不等于”。

```java
(3 > 4) == false
```

括号的运算规则和数学里面一样：**括号优先**。`(3 > 4)` 的结果是 `false`，而 `false` 确实和右侧的 `false` 相等，所以上面的整体结果是 `true`。你比 Kirara 聪明多了，不是吗？

> Kirara：我这一枪中得是不是有些莫名其妙？！

……嘛，某位大画家非要告诉我 `3` 和 `"3"` 相等，我不说是谁。记住这条原则：

**只有类型相同的表达式才可以进行比较。**

> **你是职业选手吗？**
>
> Java 没有运算符重载，所以 `>` 和 `<` 无法用在引用类型上。对于相等性比较 `==`，由于引用类型只有和自己比较才是 `true`，所以类型相同永远是前提，就没必要深究了。

## 好像似乎也许是

### 并且，同时

每次有求于 Kirara 的时候，我总会考虑一件事情。

“**如果我让 Kirara 为我画画，但我不给她钱，她就不会给我画。**”

—— 我这么想的时候，其实是同时在考虑**两个条件**：“要求画画”为 `true`（是真的，确实问了），但是“给钱”为 `false`（是假的，没给钱）。我们希望这两个条件**同时满足**，在 Java 中也有类似的方法做到这一点：

```java
a == 1 && b == 2
```

`&&` 是**与运算符（And）**，它检查左右两边是否**都是** `true`，如果是，表达式的值就是 `true`，否则是 `false`。所以，如果 `a` 的值是 `1` **而且** `b` 的值是 `2`，**左右两边都成立**，那么上面这个表达式就是 `true`，而其它所有情况下都是 `false`。

### 或者，任一

```java
a == 1 || b == 2
```

`||` 是**或运算符（Or）**，和“与”很相似，但“或”比较宽松 —— 只要两边**至少有一个**是 `true`，它的结果就是 `true`，只有当两边**都是** `false` 时，它才是 `false`（有点像 `false` 版的与运算符）。

所以，如果 `a` 的值**是** `1`，或者即使 `a` 的值**不是** `1` **但** `b` 的值是 `2`，表达式都为 `true`。只有 `a` **既不是** `1`，`b` **也不是** `2` 的情况下，表达式才为 `false`。

### 不是，反之

```java
!(a == 1)
```

`!` 是**非运算符（Not）**，不同于上面两个，它只做一件事情：将右边的逻辑值**反过来**。如果右边是 `true`，加上 `!` 之后的值就是 `false`，反之亦然。所以，它会把 `a == 1` 的结果反过来：如果 `a` 是 `1`，那么表达式值为 `false`。

对了，这里 `a == 1` 的两侧加上了小括号 `()`，代表**要优先计算**。因为，如果不这么写，而写成这样的形式的话：

```java
!a == 1
```

`!` 会优先和 `a` 结合在一起，这就没法算了（`a` 不是逻辑类型）。

> Kirara：那我在 `!` 和 `a` 之间加上一大 —— 堆空格，是不是就可以让 `a` 和 `==` 更近呢？

不行，原因如下。

> **到底怎么回事？**
>
> 在 Java 中，不引起歧义的情况下，空格可以**任意增加**，也可以**任意减少**，而它们会被 Java 直接忽略，例如 `a == 1` 和 `a==1` 以及 `a== 1` 都是**完全一样**的（当然，不能把 `==` 拆开）。即使加了一百个一千个，乃至可数或者不可数无穷多个空格，`!` 也会和 `a` 先结合。如果想让什么东西先运算，就需要**使用括号** `()`。
>
> 除了语法要求以外，在合理的地方加上空格可以让代码更好看，仅此而已。

与、或、非，都是针对**逻辑值** （`true` 和 `false`）进行运算的，合称**逻辑运算符（Logical Operator）**，它们可以组合起来实现更高级的功能：

```java
!(a == 1 && b == 2 || c == 3 && d == 4) && (e == 5 || !(a + e == 7) && (x - 8 == 6))
```

……呃，事情很快就从高级变成了乱七八糟。不过还好，复杂的逻辑关系可以用另一种方式予以表达，这就是下面的……

## 哦，选择！

### 如果……就……

如果程序只能一板一眼把两个数加起来或者减掉，可就太没意思了。请看下面的例子：

```java
int a = 1;
int b = 2;
if (a == 1) {
    b = 0;
}
```

`if` 被称作**条件语句（Conditional "If" Statement）**，你注意到 `if` 后面有一对小括号 `()`，这里面应该写一个**表达式**（本例中为 `a == 1`）。**只有当表达式的值为 `true` 的时候，大括号 `{}` 中的内容才会执行**。否则，Java 会直接跳过 `{}` 中的部分。

在这里，条件 `a == 1` 是成立的，因此 `b = 0;` 得到执行，所以，`b` 的值最终是 `0`。

!> 请注意，虽然 `if (...) { ... }` 这个写法看上去和方法的定义很相似，但 `if` **不是方法，也和方法没有关系**。小括号里放的是代表**条件**的**表达式**而不是**参数**，前面也没有返回值类型。

> Kirara：如果我想让 `a` 不为 `1` 时才把 `b` 改成 `0` 呢？

有两种办法：

- 你知道，`if` 总是在小括号 `()` 里面的内容**成立**的时候才执行。怎么把一个**不成立**的东西变成**成立**呢？你刚刚学到的**非运算符** `!` 就可以派上用场。只需要把代码改成这样：
  
  ```java
  if (!(a == 1)) {
      b = 0;
  }
  ```

- 还有一种更简单的方法，就是直接改变语义。`a == 1` **不**成立，那就是 `a` **不**等于 `1`，然后你就发现，我们有一个**不等于**运算符 `!=`，所以上面的代码可以简化成：
  
  ```java
  if (a != 1) {
      b = 0;
  }
  ```
  
  当然，只有 Kirara 会异想天开地发明出 `!>` 和 `!<` 这种写法，大家可不要学她。请好好使用 `<=` 和 `>=` 来做到一样的事情。

### 先这样，再那样

如果 `a` 是奇数，就把它加一，如果 `a` 是偶数，就把它除以 `2`。像这样的操作，用 Java 要怎么做到？

即使是 Kirara 也可以很快地写出来……

```java
if (a is odd number) ...
```

啊，这事怪我，我忘了说了，除了加减乘除之外，还有一个有用的运算符：

```java
a % 2
```

**取余运算符（Mod Operator）**`%` 将左边的整数**除以**右边的整数（必须是整数哦），并将它的**余数**作为自身的值。奇数除以 `2` 余数是 `1`，偶数是 `0`，所以如果 `a % 2` 是 `1` 就代表 `a` 是奇数，否则 `a` 是偶数（`a` 已经确定是整数了）。

下面请 Kirara 再来写一下刚才所说的代码。

```java
if (a % 2 = 1) { ...
```

……好吧，笨鸟先飞（比较该用 `==` 而不是 `=`，我们刚讲过），或许我们应该看看 Saki 写出来的代码。

```java
if (a % 2 == 1) {
    a = a + 1;
}

if (a % 2 == 0) {
    a = a / 2;
}
```

她的本意是对的，但是上面的代码**无法正常工作**。

Saki 的本意是分别用两个 `if` 来判断 `a` 是奇数还是偶数，然而，当 Java 走到第二个 `if` 时，`a` 的值可能**已经改变了**，如果 `a` 是奇数，在 `a = a + 1` 执行后，它就增加了 `1`。

也就是说，我们需要一个写法，来做这样一件事：

**如果 XXX 成立，就这么做，否则那么做。**

“如果……就……”这样的关联词，我们可以用 `if` 来做到，但是“否则”呢？

### 如果……否则……

好的，下面向你隆重介绍 `if` 的双胞胎 `else`。

```java
if (a % 2 == 1) {
    a = a + 1;
} else {
    a = a / 2;
}
```

`if-else` 也是**条件语句（Conditional "If-Else" Statement）**，注意虽然都叫条件语句，但它们的英文翻译不同，请和上面的 `if` 部分比较一下。

`else` 的中文意思是“否则”，它跟在 `if` 的大括号 `{}` 后面，自己后面还有一对大括号 `{}`。如果 `if` 小括号 `()` 中的条件**成立**，`else` **前面**的这对大括号被执行，反之如果不成立，则 `else` **后面**的被执行。我们会说：

**如果 `if` 的条件成立，`if` 后跟随的语句被执行；不然的话，`else` 后跟随的语句被执行。**

下面来看一些例子：

```java
if (a > 3) a = a - 1;
else a = a + 2;
```

注意到这里我们**省略了**两对大括号 `{}`，这是因为，如果 `if` 和 `else` 的后面只跟随了**一条**语句，就可以**省去大括号**。如果超过一条，就不可以偷懒。上面代码的意思不难理解：如果 `a` 大于 `3` 就将它减去 `1`，否则加上 `2`。

### 打破砂锅问到底

条件语句可以一层一层**嵌套**起来：

```java
if (age > 18) {
    // 大于 18
} else {
    if (age > 16) {
        // 不大于 18，但是大于 16
    }
}
```

从上面的代码中，你会发现尽管在第二个 `if` 的条件中，我们只检查了 `age` 是不是大于 `16`，然而，由于它在 `else` 部分的**里面**，`else` 表示“否则”，其**隐含了 `age > 18` 不成立**这个条件。因为，如果 `age > 18` 成立，**第一个大括号就被执行了，压根轮不到第二个** `if`。

!> 请注意，**所有**的括号都是要**一一配对**的，从最后一个左括号起，每一个左括号向右匹配**最近的**一个右括号，但是**已经被匹配的不能再用**。有时由于括号太多，找到配对的括号是一件很困难的事情。

我们顺便还要提及一个事实：尽管 `if (...) { ... }` 这个结构可以跨越很多行，也可以长得很大，里面还可以包含其它很多语句，但它自己是**一条**语句，这种以大括号结尾的特殊结构不需要分号，我们后面会再见到一些。

既然 `if (...) { ... }` 是**一条**语句，那么我们可以把代码简化一下，去掉 `else` 后的大括号：

```java
if (age > 18) {
    // 大于 18
} else if (age > 16) {
    // 不大于 18，但是大于 16
} else {
    // 以上都不对
}
```

这就好像在说，**如果 XXX，就这么做，不然如果 YYY，就这么做，再不济如果 ZZZ，也可以这么做，还不行吗？那就只能那么做了**。

下面是一种比较麻烦，但是可以判断一个 20 以内的数是不是质数的方法：

```java
if (a == 2) {
    // 是质数
} else if (a == 3) {
    // 是质数
} else if (a == 5) {
    // 是质数
} else if (a == 7) {
    // 是质数
} else if (a == 11) {
    // 是质数
} else if (a == 13) {
    // 是质数
} else if (a == 17) {
    // 是质数
} else if (a == 19) {
    // 是质数
} else {
    // 不是质数
}
```

*其实如果让人来判断一个 20 以内的数是不是质数，许多人的大脑也是用这样的方法判断的，而不是“一眼就看出来”。*

如果我们希望很多条件**同时**成立，可以利用**与**运算符（表示“并且”），写出这样的代码：

```java
if (a == 1 && b == 2 && c == 3 && d == 4 && e == 5) {
    // ...
}
```

你可以把它们改写成这样：

```java
if (a == 1) {
    if (b == 2) {
        if (c == 3) {
            if (d == 4) {
                if (e == 5) {
                    // ...
                }
            }
        }
    }
}
```

上面的程序是这个意思：“`a` 等于 `1` 吗？不是？那就算了。是的？那么 `b` 等于 `2` 吗？”……这样**从外到内，一层一层**地进行判断。只有**每一个 `if` 的条件都成立**，最里面的部分才会被执行，只要有一个 `if` 不成立，它对应的大括号 `{}` 就会被跳过。**不管是哪个大括号 `{}` 被跳过，它里面的其它 `if` 都不会再判断**，也就没有机会执行到最里面的部分。

有些工程师认为第一种写法容易“头重脚轻”，而更多工程师（包括我）认为第二种写法的“走楼梯”显得更难看。这个例子只是为了让你感受一下多个 `if` 嵌套的“**同时成立**”的感觉。

## 加加减减

软件工程师们经常会用到这样的写法：

```java
a = a + 1;
b = b - 1;
```

由于加一和减一比较常用，因此大多数编程语言都发明了一种**简写的方法**，Java 也不例外：

```java
a++;
b--;
```

`a++` 就代表“把 `a` 的值加一”，`b--` 就代表“把 `b` 的值减一”，这两个都是把**自己**增加或减少，所以一个称作**自增运算符（Self Increment）**，一个称作**自减运算符（Self Decrement）**。

> Kirara：如果 `a` 是一个字符串，比如 `"我是 No."`，`a++` 也一样能得到 `"我是 No.1"` 吗？

不行。`++` 和 `--` 只能用于**数字计算**。字符串的拼接，还是得乖乖用 `+` 完成。

> **你是职业选手吗？**
>
> 以前，在原生语言（C / C++ 等）中，`++` 运算符在支持的处理器上会用 `INC` 指令代替传统的加法 `ADD`。“加一”这个操作在硬件电路层面上有单独的、更快的电路来做这个操作。自增和自减由于在计数循环中用得比较多，执行起来频率很高，所以会做这个优化。现今，由于大多数处理器内部的电路已经优化得相当完善，`INC` 和 `ADD` 相比差距并不大，所以 `++` 和 `--` 的使用，更多是出于编码层面上的简洁考量。

## 如何对付无穷无尽的整数

### 再来一遍

只要 `a` 大于零就不断为 `a` 减一，直到 `a` 等于零。

你会发现 Kirara 正在写出这样的代码：

```java
if (a > 0) a = a - 1;
if (a > 0) a = a - 1;
if (a > 0) a = a - 1;
if (a > 0) a = a - 1;
if (a > 0) a = a - 1;
if (a > 0) a = a - 1;
// 省略下面的许多行
```

她试图**写出很多很多条语句**来做到这点。这个做法的问题，并不只是在于麻烦，而是“**到底要写多少次**”？如果 `a` 是 `100`，而这里只写了 99 个 `if`，结果就不对，所以我们要**写很多很多语句，比任何一个数都要多**。但是，整数没有界限，**想多大就可以多大**，所以我们哪怕一直写下去，也无法保证“比每个整数都大”。即使是通过复制粘贴来完成这个工作，让程序长度以指数增长的 Ctrl-C 加 Ctrl-V 也会很快被湮没在无边无际的整数大海中。

下面向你介绍对付整数大海的大杀器。

```java
while (a > 0) {
    a = a - 1;
}
```

`while` 是**循环（"While" Loop）**，它长得和 `if` 很像，做的事情也很像：

**只要小括号 `()` 中的条件（表达式）为 `true`，就执行大括号 `{}` 中的内容……**

> Kirara：这不是没有区别嘛！

你先别急，因为还有下半段：

**……执行一次后，再次判断条件是否成立，如果条件依然成立，就回来再执行一次大括号 `{}` 中的内容，只要条件一直成立，就一直执行，直到条件不成立为止。**

小括号 `()` 中的表达式被称为**循环条件**，大括号 `{}` 中的语句被称为**循环体**。

所以 `while` 做的事情大概是这样的：`a` 大于 `0` 吗？是的，那么，把它减掉一；回来，现在 `a` 还是大于 `0` 吗？是的，那么再把它减掉一……

也许就在几秒之后，也许过了几百年，不过终于有一天，`while` 发现 `a` 变成 `0` 了，**条件 `a > 0` 不再成立**，它结束它的任务，然后继续执行它下面的内容，去找下一个要吃掉的整数。

下面我们给出循环的正式定义：

**只要 `while` 的条件为 `true`，循环就一直执行下去，每当判断成功一次，就执行一次，直至条件变为 `false`，或者被打断。**

### 任何邪恶，终将绳之以法

```java
int a = 5;
while (a > 6) {
    a = a + 1; // 这不会执行！
}
// 这里 a 还是 5
```

如果循环的条件**一开始就不成立，它就什么也不做**，这一点和 `if` 一样。`5 > 6` 不成立，所以 `a = a + 1;` 虽然写在了这里，但也**一次都不会执行**。

> Kirara：如果 `a` 一开始是 `7` 呢？

那么，由于 `7 > 6` **成立**，`a = a + 1` **被执行**，`a` 变成 `8`，`8 > 6` **还是成立**，于是 `a` 变成 `9`，然后是 `10`，`11`，一直到一百，一千，一万，一直到即使是最大的 CPU 也装不下的数。

然而，循环也不会在这里停下，它很忠诚，“**只要条件成立，就执行**”，它会一直给 `a` 不断加一，期待着 `a` 变得比 `6` 小的一天。

可惜，这一天**永远不会到来**，`while` 也**永远不会停下**，一直到永恒石都化为了尘土，落雪之森的千年老树悉数枯亡，防御塔永不熄灭的光球变得暗淡无光，一直到连时间的尽头都过去了很久很久很久，它依然在向后数数，判断，执行，判断，执行。

像这样的循环就被称作**死循环（Dead Loop）**，程序会一直卡在这里。相信你已经不止一次用“任务管理器”来停下卡死的程序，虽然不至于把你一路带到时间的尽头，但**死循环可不是个好主意**，所以，请记住以下的原则：

**请让循环条件有机会变成 `false`，或者手动打断它。**

怎么手动打断一个循环呢？请看下面的例子。

```java
int a = 0;
while (true) {
    a = a + 1;
}
```

`true` 永远都是 `true`，所以这是一个**死循环**，这可不太好。

你可以用 `break` 来打断一个循环，用法如下：

```java
int a = 0;
while (true) {
    a = a + 1;
    break;
}
int b = a;
```

`a` 从 `0` 开始，`while` 先给 `a` 增加 `1` 把它变成 `1`，这很简单，它继续看下一行……然后，一个奇怪的家伙出现了：`break`。

`while` 挠了挠头，不知道这是什么意思，它正打算忽略它，准备回到开头再来一次，但是 Java 突然跳了出来，拦住了它，“**和蔼！任何邪恶，终将绳之以法！**”

Java 看到了 `break`，知道我们想要**打断循环**，于是它把马上要走向失控的 `while` 循环抓住，将它**停下来**，然后继续执行之后的内容（`int b = a`）。`a` 只被 `while` 加了一次，所以最终 `b` 的值是 `1`。

**`break` 打断其所在的循环中最内层的循环，并从循环后的下一条语句继续执行。**

之所以说是“最内层”，是因为就像 `if` 一样，**循环也可以嵌套**：

```java
int a = 5;
while (a > 0) {
    while (true) {
        break;
    }
    // break 后，程序将从这里继续
}
```

这里，当执行到 `break;` 语句时，尽管 `while (true)` 和 `while (a > 0)` **都包含**了这个 `break`，但 `while (true)` **更接近** `break`（它在 `while (a > 0)` 的循环体里面），所以 `break` **打断这个条件为 `true` 的循环**，然后从有注释的那一行继续，**完全不干涉** `while (a > 0)` 的执行。

这也就是说，想要**一次性打断所有的循环**是不可能的，只能**从内到外**一层一层进行 `break`：找到第一个循环打断后继续执行的位置，在那里放一个 `break;`，然后再看这个 `break` 打断后会走向哪里，在那里再放一个 `break;`……以此类推。

> **你是职业选手吗？**
>
> 在 C 和 C++ 中很常用的 `for` 循环，在 Java 中其实通常不以 `for (int i = 0; i < n; ++i)` 这样的形式出现，而是以 `for (String s : lines)` 这样的遍历形式出现的，为了介绍这种形式，我们必须先接触对象的概念，而这就得放在下一节再讲了。

## 从半路返回

你还记得**方法**，不是吗？那些可以把一些语句**打包**起来，接受一些**参数**，还能**返回**一些值的东西：

```java
int add(int a, int b) {
    return a + b;
}
```

现在假如我们要编写一个方法，把 `a` 和 `b` 相除，该怎么写？

让我们看看我们的大画家现在在写什么：

```java
double divide(double a, double b) {
    return a / b;
}
```

她很聪明，她知道除法的结果可能是小数，所以把 `int` 换成了 `double`。在 Java 中，如果用 `int c = 3 / 2;` 这种方法来写除法的话，虽然**算出来是** `1.5`，但是由于 `c` **只能是个整数**，因此 Java 会把 `.5` 给粗暴地**切掉**，只留下 `1` 赋给 `c`。只有使用 `double`（小数）才能得到正确的结果，

但是，还有一个很麻烦的问题没有解决……

—— **如果 `b` 是 `0` 怎么办？**

如果 `b` 是 `0`，直接做除法会把程序崩溃掉。所以，我们得改变一下方法的设计，**我们希望在 `b` 是 `0` 的时候返回** `0`（请数学好的朋友稍微忍耐一下），为了做到这一点，我们会写这样的代码：

```java
double divide(double a, double b) {
    double c = 0;
    if (b != 0) {
        c = a / b;
    }
    return c;
}
```

借助一个**中间变量** `c`，我们先让它等于 `0`，然后判断 `b`，如果 `b` 不是 `0`，就把 `c` **修改为**除法的结果，然后最后一起把 `c` **返回**给调用者。

如果让我来写上面的代码，我不会用中间变量，而是这么写：

```java
double divide(double a, double b) {
    if (b == 0) {
        return 0;
    }
    return a / b;
}
```

这一个方法里竟然出现了两条 `return`……！好吧，其实没什么大惊小怪的，请记住如下的规则：

**只要在方法中执行到了 `return`，就结束方法，并把 `return` 后的值作为返回值。**

这也就是说，`return` 可以用来**提前结束**方法。不管方法内部的结构如何复杂，`return` 有多少条，Java 都只会按照**正常的执行流程**处理语句，但是**如果它碰到一个** `return`，它就把后面的值记下来作为**返回值**，然后**停下，离开**方法，**不管其后还有没有语句，亦或是有没有在执行的循环等**。

请看下面的例子：

```java
int foo() {
    int b = 1
    return 0;
    while (true) {
        b = b + 100000000;
    }
    return b;
}
```

这里出现了一个**死循环**！好恐怖！如果不做些什么的话，由于**循环条件是** `true`，`b` 就会**不停地**增加 `100000000`，向着无底的整数深渊一路坠落下去。

不过，当你仔细看看，就会发现在这个可怕的整数深渊前方，有一位忠实的骑士**拉了你一把**：`return 0;`。

程序执行到这里，**半只脚都已经踏进**循环的深渊了，但是 Java 忽然**看到了这个** `return`，于是它**离开这个方法**，只带着一个小巧可爱的 `0`，而不是去算 `b + 100000000`，还有那无穷无尽的数。

下面还有一个例子：

```java
int foo(int a) {
    while (a > 0) {
        a = a - 1;
        if (a == 2) {
            return 0;
        }
    }
    return 1;
}
```

在这里，如果 `return 0;` 被执行，Java 就会把 `0` 作为方法 `foo` 的返回值，然后**离开方法**，**无视**还没有结束的 `while (a > 0)` 这个循环 —— **它不在乎，它已经得到了它想要的东西：返回值**。

既然都说到这了，就让我再讲一个故事吧。

> **猫猫刺客 Neko 的后续**
>
> 在密林中游走，躲开来自飞雪防御塔的攻击，绕过私人住宅的层层机关，这只由于基因突变而获得智力的猫猫刺客 Neko，虽然总是尽心尽力地执行着雇主的任务，但是当她提着仇人的灵匣碎片来找雇主要钱时，他们却总是扣扣索索的。Neko 自己也明白为什么 —— **仇敌已经死了，再讨好眼前这只没人要的小猫，已经没有意义了**。
>
> 他们不知道的是，Neko 自己也有一张小小的名单，她不允许任何人白嫖她的力量 —— 即使是在一天的追捕之后，躺在风云峡谷的野花地里，她也不忘擦擦沾着曾经雇主鲜血的爪子，然后奖励自己一块小蛋糕。
>
> 有两件关于 Neko 的事鲜为人知：其一是，和传说中说的一样，她确实有九条命；其二是，她曾经也认为，善有善报，恶有恶报。

## 永恒并不完美

### 变量的生命是有限的

你已经非常熟悉于这样的写法：

```java
int a = 5;
if (a >= 5) {
    a = 6;
}
```

就在几天前，在我开始写《插件设计与编程》之前，Kirara 看到了我写的这样一段代码：

```java
Entity host;
if ((e instanceof PlayerEvent)) {
    Player host = e.getPlayer();
}
```

她立马告诉我：

> Kirara：你不是说过，变量不可以重新定义吗？

她没有说错，只不过这句话要加上一个前提条件：在**同一个块**内，同名的变量只能有一个。

什么是一个**块**呢？用大括号 `{}` 包裹起来的一个区域，就是一个**块（Block）**。这里的大括号包括了方法、循环、`if` 和 `else`，还有我们未来将要提到的类定义中的大括号。在 Java 中，**所有的 `{}` 都代表一个块**。

```java
if (a > 0) {
    // 1
    if (a > 2) {
        // 2
    } else {
        // 3
    }
}
```

上面的程序中总共出现了**三个**块，我用数字在这里给你标记了各个块的编号。

那么，块有什么用呢？请看下面的代码：

```java
int a = 0;
if (a == 0) {
    int b = 1;
}
// 在这里，我们还能使用 b 吗？
```

你会发现这里有一点蹊跷：`a` 是定义在**最外面**的，而 `b` 定义在 `if` 的大括号 `{}` 里，也就是 `if` **块**里。我已经在注释中提出了一个问题：在我标记的地方，**还能使用 `b` 吗**？

答案是**不行**。

在 Java 中，变量**并不是永恒的**，每个变量**只能“存活”到它所在的块的尽头**。

也就是说，在上面的程序中，尽管我们在第三行就创建了变量 `b`，但由于 `b` 是在 `if (a == 0)` 之后的这样一个**块**内定义的，它会随着这个块的结束而**一并消亡**。

当我们走到第四行的右括号 `}` 时，`b` 就到达了**生命的末尾**。Java 会将它**清除**，`b` 这个名字再次变得**空出来**，可以**留给其它变量使用**，就好像**它从来不曾存在一样**。

所以，在第五行，`b` **已经消失**了，我们能看到的，只有从程序开头就和我们在一起的 `a`。而且，如果不是 `a` 等于 `0` 的话，我们**甚至从来都不会见到** `b`（条件不成立，括号里的内容不会执行）。

?> 块 `{}` 的结束就好比**删除存档**，不论你**在世界中**曾经挖到过多深的洞穴、战胜了多少怪物、建造出了多么精美的红石机械……这一切，都会随着存档的删除而**消失殆尽**，就好像它们**从来不曾存在**一样。

虽然这是个很悲伤的故事，但不如说，正是因为变量会创建也会消失，Java 才能够**及时清除掉不用的变量**，使得我们的程序中不至于塞满各种各样的垃圾，也不用在选择变量名的时候犹豫不决，担心重名。

### 强龙不压地头蛇

```java
int a = 0;
if (a == 0) {
    int a = 1;
}
a = a + 1; // a 是多少？
```

`if` 的块 `{}` 外面有一个 `a`（`int a = 0`），里面竟然还有一个 `a`（`int a = 1`）！这难道不是**重名**了吗？万万不能容忍！

好吧，也许，我应该再讲一个故事。

> **我的大画师**
>
> 我和 Kirara 的相遇，其实是非常偶然而且搞笑的。
>
> 大家都知道，约稿是要收定金然后报价的，任何人问一句“能免费画一张看看吗”这种问题，都会被嘲笑“异想天开”，这确实合理 —— 画师也是要吃饭的。
>
> ……好吧，我无法理直气壮地这么说，因为我也做过相同的事情。我当时正在做一款新游戏，而我很快就意识到，需要一位画师来负责美工。项目的合作者里有不少人能写歌，但是却没有能画画的。众人筹措一番，发现的确囊中羞涩，连请一位画师的定金都付不起。
>
> 也就是在那时，我认识了 Kirara。当我向她提出这个问题时，她虽然也是一脸“你想什么呢”的表情，但她仔细问了问我的项目，想了一下，然后第二天，她告诉我：
>
> “你要答应，让我第一个玩到。”
>
> 那是我们第一次合作。我和她都没曾想到，自那之后很多年，我们都一直在一起。她的绘画技艺日益精湛，而和她一同工作的时间，也逐渐有了淡淡的甜味。从陌生人到合作者、朋友、好朋友，再到更进一步的，超级好朋友。
>
> “我可算是把自己卖了呢。”她总是这么说。
>
> 尽管 Kirara 依然是名不见经传的小艺术家，尽管**除了我以外没有人**会叫她“大画师”，尽管她打字仍然是一指神功，尽管她孩子气、调皮，还喜欢时不时来一下恶作剧，但她仍然是**我最喜欢的，最好的“大画师”。**

Kirara 是**我心目中**最好的大画师，也就是说，她在**我这个块**里，是“大画师”。除此之外，在**更大的块**里没人叫她“大画师”，“大画师”这个名字，只对于**我这个块**有意义。所以，也许会有其他人被叫做“大画师”，但无所谓，我可不管，我的“大画师”就是 Kirara。

> Kirara：下次不许拿我举例子！（气鼓鼓）

现在，让我们再看一下上面的程序：

```java
int a = 0;
if (a == 0) {
    int a = 1;
}
a = a + 1; // a 是多少？
```

在最外层有个 `a`，是**大家公认的** `a`，但是在 `if` 块里面，我们又创建了一个 `a`，而这个 `a` 只**在这个块 `{}` 里才有意义**，“此 `a` 非彼 `a`”，在 `if` 的这个**块里**给 `a` 赋值时，其实是在修改**第三行创建的**变量 `a`，**不会影响到**外面的 `a`，而当我们在第五行再寻觅 `a` 的时候，在大括号 `{}` **里面**的那个 `a`，已经和之前提到过的 `b` 一样，**不存在了**。

在大括号外面我们**看不见里面的东西**，对于最后一行的 `a = a + 1` 而言，这个 `a` 还是第一行的 `a`，其值为 `0`。所以，在最后一行，`a` 被修改成 `1`，而且，这个被修改的 `a` 还**不是第三行的** `a`（它已经**消失**了），而是**最早**和我们在一起的 `int a = 0;` 所创建的 `a`。

所以，我们总结出有关块的几条规则：

- 一个变量在定义后，可以在它**所属的块**，以及它**里面包含的块**使用，只要**没有定义同名的新变量**，使用到的都是同一个变量。
  
  ```java
  int a = 1;
  if (true) {
      a = a + 1; // a 被加一变成 2
      if (true) {
          a = a + 1; // a 又被加一变成 3
      }
  }
  int b = a; // b 是 3
  ```

- 一个变量在到达它**所在块的末尾后**，就会被**销毁**，无法再使用。
  
  ```java
  if (true) {
      int b = 1;
      // b 在这里还可以使用
  }
  int a = b; // 不行！b 现在已经不存在了
  ```

- 在一个块**里面**可以创建和外面**同名的变量**，但如果这么做，**在这个块里面**的剩余部分，使用这个名字时，只会找到**新创建的变量**，在这个块**结束之后**，再使用这个名字，就会找到原来的变量。
  
  ```java
  int a = 1;
  if (true) {
      int a = 2;
      int c = a; // c 是 2，这里的 a 指的是上一行的 a 
  }
  int d = a; // d 是 1，a 指的是最开头的 a
  ```

### 全部都等于零！

有关块的规则，即使是在**方法**中也不例外：

```java
void hello(int a) {
    a = 2;
}
int a = 1;
hello(a);
int b = a; // b 是 1
```

在第二行中，我们尝试把 `a` 的值修改为 `2`，但由于这是**在方法的块**中，我们实际上修改的是第一行的**参数** `a`（还记得吗，参数就像事先定义好的变量），而这个参数 `a` 和下面的 `a` 并**不是同一个**变量，它们仅仅是叫同一个名字。

Java 在第五行**调用** `hello(a)` 的时候，其实是先**算出**参数的值 `1`，然后**来到第一行**，把参数 `a` 设置为 `1`，相当于**在方法里面**定义了一个**新的**变量 `a`，这时在方法**里面**再使用 `a` 这个名字，就和外面的 `a` 没什么关系了。

如果你还觉得难以理解，就看看下面这个荒唐的例子：

```java
void hello(int a) {
    a = 0;
}

hello(1);
```

如果我们对参数 `a` 赋值能够影响到外面的参数 `1` 的话，那就是把 `1` 变成了 `0`。

这下可糟糕了，我们只要在 `hello(?)` 的问号 `?` 处**填上随便一个数，就能把它变成** `0`！于是一瞬间，你的期末考试成绩全都变成了 `0`，你最喜欢玩的服务器变成了 `0`，`cos 0` 也变成了真正的 `0`，地球立刻消失了，因为它的大小变成了 `0`，万事万物立马全都不见了，它们都变成了 `0`，甚至即使是“什么也没有”这五个字也不见了，因为 `5` 也变成了 `0`。

这么可怕的事情当然不会发生，因为参数 `a` 在**方法内部才有效**，而且**只能存活到方法块的末尾**。当到达方法的末尾 `}` 时，参数 `a` 连同它的新值 `0` **一起都消失了**，外面的 `1` 还是 `1`，什么也没有发生。可怕的 `0` 不会跑出来吃掉所有的数，所以，我们可以睡个好觉了。

哦对了，顺便提一句，如果你真的想在方法里面使用外面的 `a`，只需要给参数换个名字就行了（比如 `b`），这样，当你使用 `a` 的时候，Java 发现参数里面没有它，就会**自动向外面找**，然后找到外面定义的 `a`。

### 及时清理就能有备无患

下面再看最后一个例子：

```java
while (true) {
    int b = 1;
}
```

这是一个**死循环**，每次执行循环体 `{}` 中的内容的时候，Java 都会创建一个变量 `b`，如果这些 `b` 不被清除的话，程序里面就会被塞进无穷无尽的 `1`。

不过好在，你已经了解了**块**的概念，知道 `b` 虽然**每次循环**都会被创建，但是也同时在**每次到达循环体末尾** `}` 的时候被**销毁**。每一次循环时，用到的 `b` 都是**不同的** `b`，创建、销毁、再创建、再销毁……任何时刻都**最多只有一个**变量 `b`，所以，没什么好害怕的。

## 证明你是你

作为本节的结束，让我们来看一些有趣的内容。

```java
int hello(int a) {
    // ...
}

void hello(String a) {
    // ...
}

void hello(int x, int y) {
    // ...
}
```

你会发现这里有些不太对劲：我们居然定义了**三个**名字都叫 `hello` 的方法！这难道不会有什么问题吗？

先不要急着下结论，下面还有一些**调用**这三个方法的代码：

```java
hello(1);
hello(1, 2);
hello("这是个字符串");
```

现在我来问你一个问题：这三个调用，分别是调用的哪一个 `hello` 呢？

很显然，第一个 `hello(1)` 的参数只有**一个数字** `1`。这三个 `hello`，哪一个的参数是**一个数字**呢？你很快就发现，只有**选择第一个** `hello` 才看上去是合理的 —— 第三个 `hello` 需要**两个**参数，而第二个虽然只需要一个，但它需要**字符串**而不是**数字**。

所以，请记住以下有关方法的规则：

**方法可以同名，前提是，它们每一个的参数列表都不同。**

所谓**参数列表（Parameter List）**，就是把小括号 `()` 里的东西拿出来，然后扔掉参数的名字就行了。比如，第一个 `hello` 的参数列表是 `(int)`，第二个是 `(String)`，第三个则是 `(int, int)`。

在 Java 中，由于调用方法时，参数的**数量**是确定的（数数有几个逗号），而**类型**也是确定的（还记得吗，各种字面量、返回值、变量都有**确定的类型**），因此，只需要把提供的参数和参数列表**对比**一下，**哪个符合，就使用哪个**。

话说回来，为什么一开始不能用相同的名字呢？是因为担心**分不清**该使用哪一个方法。现在，既然有了参数列表，**不会引起歧义**，那么方法能同名，好像也就是理所应当的事情。

## 休息一下

我们来看看从数字 `1` 开始，一直到同名的方法，我们都知道了些什么：

- 字面量，一看就知道是什么

- 把字面量组合起来形成表达式

- 创建变量来记录表达式的值

- 程序是一条一条语句执行的

- 把语句打包变成方法

- 使用方法，给它一些参数，它还能返回一个值

- 用注释来让 Java 忽略写给人看的内容

- 比较大小，还有是不是相等

- 逻辑运算：并且，或者，不是

- 用 `if` 和 `else` 来选择性地做一些事

- 用 `while` 重复做一些事，还能用 `break` 打断

- 在到达方法末尾前用 `return` 提前返回

- 变量只在它被创建的块里有效，即使同名变量也是一样

- 给参数赋值无法改变外部的值

- 方法可以同名，前提是参数不相同

还不错！在过去的两节里，我们已经了解了 Java 的基本知识，但是这并不是 Java 最有魅力的地方 —— 在下一节，我们要介绍有关**类和对象**的知识，并且向你展示那些“看上去很酷”的代码是如何构成的。
