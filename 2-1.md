# 2-1 配置文件

欢迎回来！希望你的 HellWorld 项目完成得很顺利。

你的第一个插件做的事情很简单：在日志中输出 `hell, world`。如果我们想让它输出其它的内容呢？我们就可以修改代码：

```java
getLogger().info("hell new world");
```

想改成什么都行！然后，我们只需要再双击一下 build 按钮（在 Gradle 菜单里），就可以做出新的插件，再复制粘贴到服务器上测试……

看似一切都很自然，不过，这里有一个很重要的问题。

**如果插件的使用者不会编写代码，但又需要改变输出的内容，该怎么做？**

我们当然不能简单来一句“那就去学习 Java 呗”，这样比较伤人，而且如果做出来的插件这么不好用，也就没人会用我们的插件了。

回想一下你用过的插件，是不是大多数都需要编辑一个叫做 `config.yml` 的文件？这就是**配置文件（Config）**。

## 可定制的功能

所谓配置文件，其实也就是被我们当作“配置”的文件。

而所谓配置，其实也就是和手机电脑上的“设置”一样，可以自由定制插件的某些行为。比如，调节蓝牙的开关，设定手机的壁纸……这样的设定。

配置文件的作用就是：让**用户编辑配置文件**来描述他们想要的设置，插件再来**读取这些设置**，并按照用户的要求改变自身的行为。

假如我们想让 HellWorld 插件能够根据用户的需求，输出指定的文字（而不是固定的 `hell, world`），我们可以这么做：

1. 在插件的网站、使用说明或者手册里面，告诉用户：“请把要输出的文字写在配置文件中”。

   让我们假设用户写下了这样的文字：

   ```
   ciallo, world
   ```

2. 插件设法**读取**配置文件，并得到一个字符串（还记得吗，字符串描述一些文字）：

   ```java
   String text = doSomethingToGetTheString(); // 设法获取用户的设置
   ```

   至于究竟怎么“设法”，我们稍后再说。
3. 按照设计**改变插件的功能**，例如在 HellWorld 插件里，就是输出指定的文本：

   ```java
   getLogger().info(text);
   ```

看看，配置文件的工作原理，大致就是这样，没什么难的，对吧？

?> 像我们一开始做的，让程序直接输出 `hell, world` 这样的行为，插件处理的内容是**直接编写在代码中**的，用户无法改变，这也被称为**硬编码（Hard Coded）**。<br/>相对应的，像上面这样，用户**无需修改代码**就可以设置的内容，叫做**可配置（Customizable）**。对于插件而言，我们通常希望尽量减少硬编码，这样插件可以更泛用。

## YAML 格式

### Bukkit 提供的格式

一个插件通常会有很多配置项，如果把它们胡乱地到处乱堆，配置文件就会杂乱不堪。我们需要一种文件格式来**有序地组织各项配置**。

原则上，使用什么格式都可以，既可以是一般人办公常用的 Excel 表格，也可以是前端工程师喜欢的 JSON，还可以是 Minecraft 专属的 NBT 格式……这只牵涉到用户怎么修改配置文件，以及插件怎么读取配置文件的问题。

不过，Bukkit 已经为我们提供了一种格式，这就是 **YAML**。

Bukkit 为我们写好了一大堆好用的方法，可以操作 YAML 格式数据的方方面面。既然有人为我们做了这项工作，我们就不再舍近求远，去发明自己的格式了。

### 一个一个一个

YAML 格式的配置文件看起来像这样：

```yaml
allow: true
regen: true
location: [0, 128, 0]
hint: "已返回主城！"
```

YAML 描述的是一种“字典”格式。所谓字典，就是**一对一的关系**。比如，在上面的这段配置里，`allow` 对应 `true`，`regen` 也对应 `true`……

这样是不是很符合“配置”的特征？我们想要知道用户是否希望插件生效，就查看 `allow` 对应的是 `true` 还是 `false`；如果想知道把玩家传送回哪里，就查看 `location`……

像这样的每一条对应关系，就是一项设置，称作一个**配置项（Entry）**。写在冒号 `:` 左边的，表示“这个设置是什么”的，叫做**键（Key）**，而用户填入的，要被插件获取的具体数据，叫做**值（Value）**。键与值之间，使用冒号加一个空格 `: ` 来分隔。

?> YAML 不是一种编程语言，它只是一种格式，一个约定，它规定用户怎样对插件进行设置。具体有哪些配置项，每个配置项做什么，是完全由插件来决定的。

### 数据类型

我们刚才提到过，冒号 `:` 左边的是键，右边的是值。

键是配置项的名字，因此它没有什么类型之分 —— 都是字符串，而且不需要引号，直接写出来就行了。

相比之下，值就有趣得多。YAML 中的值有以下几种：

- 数字，例如 `123`、`-32768`、`114.514` 等。

- 逻辑，只有 `true` 和 `false`。

- 字符串，例如 `"Ciallo～(∠・ω< )⌒☆"`。

- 列表，例如 `[1, true, "foo"]`。可以保存一列其它种类的数据，包括数字、逻辑、字符串、下面要说到的字典，乃至列表本身！

- 字典，一些键和对应的值，值可以是上述的四种类型之一，或者另一个字典！

让我们来看一个完整的例子：

```yaml
# 这是注释，不会被 Bukkit 读取
age: 18 # 数字
graduated: true # 逻辑
fav-game: "Minceraft" # 字符串
browser-history: ["aaa", "bbb", "eee"] # 列表
advancements: # 字典
  play-minecraft: true
  how-did-we-get-here: false
```

数字、逻辑、字符串我们已经在 Java 中讲解过了，这里主要有两个新东西：**列表**和**字典**。

列表，顾名思义，就是把一列值**按顺序**放在一起。可以用来保存一些玩家的名字、过去十五分钟的 TPS、服务器的更新历史之类的数据。列表里面还可以塞进其它的列表，不过一般情况下，我们用不到。

至于字典就比较有趣了。我们已经说过，YAML 自身就是一个字典结构，一个键对应一个值，然而这个值**本身还可以是一个字典**……唔，这么一想，就可以写出这样的结构：

```yaml
key1:
  name: "You"
  key2:
    another-name: "Me"
    key3:
      a-deep-key: 114.514
```

在这里，`key1` 是一个键，对应一个巨大的字典，这个字典里面包含两个键 `name` 和 `key2`，而 `key2` 对应的又是一个字典，包含 `another-name` 和 `key3` 两个键，`key3` 又对应另一个字典，只包含一个键 `a-deep-key`，对应一个数字 `114.514`。

这样的结构，从视觉上就能看出来配置之间的**层次和包含关系**，在我们想要把配置分开整理的时候非常有用。

哦对了，顺便说一句，YAML 中也有**注释**，和 Java 中的写法非常相似，只不过是用井字符 `#` 代替双斜杠 `//`，效果与 Java 中的注释完全相同。

!> 类似 Java，注释并不是一种数据类型，因此类似 `key1: # 我要成为 key1 的值！` 这样的写法是错误的。

### 合适的名字

如你所见，YAML 的写法非常简单，只需要**写出键名**，再**加上**一个冒号和一个空格 `: `，后面再**写上值**就可以了。

YAML 的键名并没有严格的规范，这主要是因为 YAML 本身不是一个编程语言（不像 Java），各种不同的软件对于 YAML 的键名要求也不尽相同。在 Bukkit 社区内，键名通常遵循如下的共识：

- 只使用数字和**小写**字母，以及减号 `-`。（例如 `player-count` 而不是 ~~`Player$Count`~~）

- 用减号 `-` 来分隔不同的单词。（例如 `game-version` 而不是 ~~`gameversion`~~）

- 数字不要出现在开头。（例如 `one-times` 而不是 ~~`1-times`~~）

当然据我们所知，有许多许多插件作者不完全遵守或者压根不关心这些规则。本书中的项目会按照这些规则命名，不过要是你有更好的主意，也完全可以在自己的项目中尝试。

## 读取配置文件

既然说完了配置文件长什么样，那么，我们要如何给用户提供配置文件呢？又要如何把用户填入的数据读取出来呢？别心急，Bukkit 已经为我们提供了一系列类和方法，下面我们就来看看到底怎么使用。

?> 有兴趣的读者可以在看下面的内容之前，先尝试在 [Paper 的 Javadocs](https://jd.papermc.io/paper/1.20/index.html) 中自行查找有关配置文件的方法，看看你能否找出一些线索。提示：可以尝试查找 `ConfigurationSection` 这个名字。

### 获取配置文件

还记得我们在 HellWorld 中是如何获取“日志记录器”的吗？是 `getLogger` 方法。由于我们的插件主类继承了 `JavaPlugin`，因此我们可以直接使用 `getLogger` 方法。

配置文件的获取，也同样非常相似。只需要使用 `getConfig` 方法，就可以获得一个“配置文件器”，说得比较拗口，或许该叫它“配置文件编辑器”。

下面是一个例子：

```java
@Override
public void onEnable() {
    ??? config = getConfig(); // 我们暂时还不知道它的类型
}
```

呃，好吧，或许我们还不知道配置文件的类型。尽管我们知道它是一个 YAML 格式的文件，但我们还不知道它在 Java（以及 Bukkit）中对应的是哪个类型。

### 配置文件类

在 Java 中，一切都是对象，配置文件自然也不例外。

既然是对象，就应该有一个类来描述它。这就是 `ConfigurationSection` 类（全名 `org.bukkit.configuration.ConfigurationSection`）。顾名思义，它描述配置文件中的一个部分（可以说是一个“切片”）。

?> `getConfig` 方法返回一个 `FileConfiguration` 对象，虽然它不是 `ConfigurationSection` 本身，但它实现了 `ConfigurationSection` 接口，因此它可以被直接当作一个 `ConfigurationSection` 来用。<br/>至于“实现接口”，暂且先把它当作是“继承”吧。我们后面再行介绍。

这个类包含了**读取和写入配置文件需要用到的方法**，主要有两类：

- 一系列 `getXXX` 方法，例如 `getString`、`getInt` 等，用来读取不同类型的值（还记得吗，YAML 中有字符串、数字……）。

- 一个 `set` 方法，用来修改配置文件。

假设有这样的一个配置文件：

```yaml
some-number: 114514
some-string: "Ciallo~"
```

如果我们想读取 `some-number` 和 `some-string` 对应的值，我们就写出下面的 Java 代码：

```java
ConfigurationSection config = getConfig(); // 先获取到配置文件对象

int a = config.getInt("some-number"); // a 被赋值为 114514
String c = config.getString("some-string"); // c 被赋值为 "Ciallo~"
```

非常直观：`getInt` 与 `getString` 都接受一个参数，也就是**键名**，它们在所属的 `config` 对象里**找到**你指定的键，然后把对应的值**返回回来**。我们再使用赋值运算符 `=` 将它们赋给新定义的两个**合适类型**的变量。

> **到底怎么回事？**
>
> 在 Java 中，变量和方法的返回值都有**确定的类型**，我们只需要查看它们的定义，就能够确定这是个整数还是个字符串，或者别的什么东西。然而，YAML 却不是这样，**键所对应的值的类型是不确定的**。随便给出一个键，例如 `key1`，没人知道在配置文件中 `key1` 后面写的到底是一个数字，还是一个字符串。
>
> 因此，Bukkit 提供了各式各样的 `getXXX` 方法，它们读取配置文件中给定的键对应的**原始数据**，然后尝试将它们**转换为**指定的类型。`getString` 转换为 `String`、`getInt` 转换为 `int`……诸如此类。
>
> 所以，假如配置文件中有一行 `key1: 123`，`getString("key1")` 会获取到字符串 `"123"`，而 `getInt("key1")` 获取到数字 `123`（一百二十三）。

`getXXX` 有许多许多方法，不仅可以获取 YAML 支持的类型，还可以获取一些 Minecraft 专属的类型，比如颜色 `Color`，位置 `Location`，乃至物品组 `ItemStack`。你可以在 [`ConfigurationSection` 类的详细信息](https://jd.papermc.io/paper/1.20/org/bukkit/configuration/ConfigurationSection.html#method-summary) 中找到所有的 `getXXX` 方法。这里就不一一列出了。

所以总结一下，要读取配置文件，就是先用 `getConfig` 方法**获得配置文件对象**，再在这个对象上调用 `getXXX` 方法**获得键对应的值**。其中 `getXXX` 应当选取**与值的实际类型相符**的版本（例如字符串用 `getString`，逻辑用 `getBoolean`，等等）。

### 默认配置文件

如果我是魔鬼，我就会让用户新建一个空白的 `config.yml` 文件，然后写上他们想要的配置。可是，这样做明显不现实，假如插件读取的是 `some-string` 这个键，用户如果不知道插件的工作原理，即使试上一百年也不一定猜得出来。即使看过代码或者文档，知道我们会读取哪些键，但是从一个空白的文件开始编写 YAML，不仅容易出错，还很让人烦。

大多数插件都会在第一次使用时，**创建一个默认的配置文件**，里面包含了插件配置的**模板**。用户只需要对这份文件做一些修改就可以使用了。

默认配置文件可能看上去像这样：

```yaml
database:
  type: "MySQL" # 默认 MySQL，可根据需要选用 Sqlite
  user: "数据库用户名" # 填入数据库用户名
  password: "数据库密码" # 填入数据库密码
  ip: "localhost" # MySQL 需要，非本地数据库请自行配置 IP
  port: 3306 # MySQL 需要，若不是默认端口请修改
  file: "data.db" # 若选用 Sqlite 需要填写此项
```

这样用户只需要根据服务器的情况修改各个值就行，完全不需要从头开始输入，是不是方便了很多？

那么，默认配置文件要怎么创建呢？要怎么“检测第一次运行，然后保存默认配置”呢？Bukkit 同样为我们提供了一个简单的方法。主要有两步：

1. 在项目中**创建**一个默认配置文件，名为 `config.yml`，在其中写入默认配置或模板。

   具体这个 `config.yml` 创建在哪儿，我们稍后会在项目中演示。现在你只需要知道，“哦，需要有 `config.yml` 这么个文件”，

2. 在 Java 代码中**调用** `saveDefaultConfig` 方法来保存默认配置文件。

   `saveDefaultConfig` 同样是 `JavaPlugin` 的一个方法，它帮我们操心好了一切：如果用户已经创建或者修改了配置，它就什么也不做；否则，它会把 `config.yml` 复制一份，并放在用户可以修改的地方。

就这么简单，我们只需要创建一个文件，然后在插件的 `onEnable` 方法（还记得吗，插件从 `onEnable` 这里开始执行）里面调用 `saveDefaultConfig` 就好啦！我们不需要自己去检测配置文件是不是已经存在，Bukkit 会帮我们做好一切的。

---

> Kirara：如果我想修改配置文件呢？

呃，有时候是有这个需要，不过我先暂时告诉你：**不要修改配置文件**。

> **到底怎么回事？**
>
> 配置文件是用户意愿的表达，操作配置文件，就等于你在代替用户做出决定。
>
> 用户对于配置文件一般有一个期待：**只要不加修改，它总是保持不变的**。这就像 Minecraft 里的箱子，只要没有被动过，里面的物品就应该保持原状。
>
> 如果插件自行修改了配置文件，而没有告知用户，那么用户发现服务器不能正常工作时，就得花费更长的时间来排查问题，因为他们不会想到一个**没有改动过配置**的插件，竟然**自己把配置文件修改过了**。
>
> 我们没必要为任何人增添额外的麻烦，如果配置文件中的值需要纠正，在程序内部纠正就可以了，没必要去动用户的配置。而如果插件发生了大改，配置文件的结构换新了，那么可以给用户一个提醒，建议他们重新配置。

---

有关配置文件的内容说得够多了，相信大家也厌烦了，下一节里我们会讲一些好玩的东西。
