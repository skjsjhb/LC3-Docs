# JA-3 Java 面向对象（上）

# 

## 比较文字

你应该还记得，我们**不可以**用 `==` 来比较两个字符串：

```java
String s = "Ciallo～(∠・ω< )⌒☆";
if (s == "Ciallo～(∠・ω< )⌒☆") { // 不要这么做！
    // ...
}
```

即使左右两边的字符串**确实一样**，但 Java 会对第二行的相等 `==` 比较给出 `false` 的结果。

正确的方法是这样：

```java
String s = "Ciallo～(∠・ω< )⌒☆";
if (s.equals("Ciallo～(∠・ω< )⌒☆")) {
    // ...
}
```

`equals(...)` 看上去很像一个**方法调用**：方法名，小括号，参数……是的，`equals` 确实是一个**方法**，它返回一个逻辑值（`true` 或 `false`）来描述两个字符串是否相等……不过这看上去**有点奇怪**！

我们把引号里的字符换成更正常一点的省略号，然后把它拿出来看看：

```java
s.equals("...");
```

我会告诉你，`equals` 是这个方法的名字。马上 Kirara（还有你）就会提出两个问题：

- 我们没有定义 `equals`，`equals` 是从哪来的呢？

- 前面的 `s.` 是什么呢？

在本节的剩余内容中，我们会解答这两个问题，同时也向你揭开 Java 最为强大而神秘的面纱 —— **对象**。

## 找不到对象

你一定在各种网站上都见到过这个经典的**程序员笑话**：

![.](https://s2.loli.net/2023/12/24/OP9wZLIYSiyMhHN.jpg)

当然，你那聪明的脑袋肯定知道，这里的“对象”可不是“婚姻的另一半”，但是，你搜遍了脑海中的词汇，也想不出来哪里还有“对象”这个词。

“对象”一词的英文是“Object”，在中文里，类似的意思其实是“**东西**”、“**物件**”。也就是说，“对象”实际上是一个很宽泛的概念 —— **任何东西都可以叫做“对象”**。数字是对象，一些文本是对象，一条狗是对象，一个杯子是对象，就连一个程序本身也可以是一个对象。这么说可能有些拗口，不过暂且就把“对象”当作是“东西”的意思吧。

即使是东西之间也有差别，比如，一个杯子会有容积，但是一个数字却没有什么“容积”；一块红石粉有“亮起”和“熄灭”之分，而一个活塞却不会“亮起”或者“熄灭”。

在程序中，如果我们想要描述一个杯子，我们会**定义各种变量来描述它的方方面面**：

```java
double height = 10.0; // 高度
double radius = 4.0; // 底边半径
double price = 100000.0; // 价格
String brand = "沃兹基卞德"; // 品牌
// ... 诸如此类
```

像这样定义了很多变量，虽然确实可以用来描述一个杯子，但是这体现不出来它们的**关联关系**：半径、高度、价格、品牌，本来都应该是属于**一个杯子**的信息（数据），但是在上面的代码里，我们完全看不出这一点。如果不是刻意联想，谁也猜不出来这些变量是“一个杯子”包含的数据。

像这种**属于**某个**对象**的数据，叫做对象的**属性（Property）**。RPG 游戏里面的“属性”通常指角色的数值（攻击力、防御力、速度），某种意义上，这和编程中的“属性”，还真就是一个意思。

有没有什么方法可以像“打包语句成为方法”一样，把这些**属性**也**打包**起来呢？你可能会想，要是有这样的写法就好了：

```java
cup {
    double height = 10.0;
    double radius = 4.0;
    double price = 100000.0;
    String brand = "沃兹基卞德";
}
```

这看上去确实直接多了：**一个叫做 `cup` 的东西，包含有四个变量（属性）**。没错，这种写法虽然语法上很不正确，但是已经**非常接近正确答案的思路了**。

下面向你隆重介绍和对象紧密相关的概念 —— **类**。

## 自定义类型

在定义变量的时候，我们会给变量一个**类型（Type）**：

```java
int a = 1;
double b = 2.0;
boolean correct = true;
String yuzuSoft = "Ciallo～(∠・ω< )⌒☆";
```

`int`、`double`、`boolean`、`String` 都是**类型**。还有没有别的类型呢？有多少种类型呢？

答案是可以有**任意多**种类型 —— 想要有多少，就有多少。因为我们可以**创建自己的类型**。

在 Java 中，**一切都是对象**。数字 `1` 是对象，它的类型是 `int`，字符串 `"Ciallo～(∠・ω< )⌒☆"` 也是对象，它的类型是 `String`……如你所见，**类型用来描述对象“是什么”**。

既然刚刚提到了杯子，那么现在就让我们来创建一个叫做“杯子”的类型吧！

```java
class Cup {}
```

好了，恭喜，这样我们就**创建了一个叫做 `Cup` 的类型**。语法是出乎意料的简单啊：首先是一个 `class` 开头，这是固定写法，然后是**类型名**，这里我们叫做 `Cup`，最后是一个大括号 `{}`，里面包含类型的**具体信息**。

好啦，你已经知道怎么自定义类型了，下面让我们来定义 Minecraft 中的“方块”和“物品”……

```java
class Block {}
class Item {}
```

我们还可以一口气定义出来“食物”、“药水”、“剑”、“斧”……

```java
class Food {}
class Potion {}
class Sword {}
class Axe {}
```

……等等等等等等！我们玩得似乎有些太过火了，冷静下来再看看，这些类型除了名字不同，它们的具体信息都是 `{}` —— **空的**！空的类型基本上除了名字，和“什么也没有”差不了多少，这可没意思。

好吧，我们刚才已经提到过了，大括号 `{}` 里需要写上**类型的具体信息**。什么东西是“**具体信息**”呢？让我们再来讲个故事。

> **樱云与夜咲的前传**
> 
> “光”，这片大陆的名字。多数人都认为，“光”没有创世神。在有万事万物之前，在有这片大陆之前，“光”就是光 —— 没有颜色的，纯粹的，光。那时候，没有飞禽走兽，没有黑白善恶，就连“世界”这个概念本身，都模糊不清。一切都是一样的 —— 光。
> 
> 直到，什么东西发生了一点改变。
> 
> 我们不得而知发生了什么，但是，纯粹的光**有了颜色**，从纯粹的宁静变得绚烂多彩，然后，每种颜色的光，随即变成了风、火、水、电、天、地等**各种元素**，而这些元素聚集在一起，剧烈地反应，从一种东西变成另一种，然后又马上四散开……
> 
> 等一切喧嚣都宁静下来，尘埃落定，世界被分成天地两半，而大地又分作六大岛，飞禽走兽由各种元素衍生出来，直到人类诞生在这片大陆上。六大主岛，**各为传奇，各具特色**，于是被人们分别称作：樱云、夜咲、风月、星尘、源点、终焉。

最初，世界只有光，没有什么方法来区分它们 —— 所有的东西，都是一个样子。直到后来，每种光有了不同的颜色，我们才能够区分它们。类似的，食物与剑有什么不同呢？食物能恢复饥饿值，剑不能；食物没有伤害，剑有伤害……是这些**属性的不同**让我们能够区分不同的东西。

在 Java 中，事情也是基本一样的：

- **类型**是用来描述不同的对象的。食物和剑不同，因为它们是**不同的类型**。那，类型之间有什么不同呢……

- 不同的类型拥有**不同的属性**。食物有恢复量，而剑没有；剑有耐久，而食物却没什么所谓的耐久。

**我们应该把程序所感兴趣的，属于一个类型的“特色”的信息，写在类型的定义 `{}` 里。**

比如，对于一个杯子，如果我们想让程序处理它的高度、半径、容积，我们就会这么写：

```java
class Cup {
    double height;
    double radius;
    double volume;
}
```

非常像我们上面自己发明的那种写法，我们也是同样**创建了一些变量**，这些也就是 `Cup` 类型的**属性**。只不过，这些变量都没有值。为什么没有呢？请看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 类型是用来描述对象的。一个杯子可以有高度、半径、价格这些**属性**，然而对于不同的杯子，它们的这些属性可不完全一样。类型描述的是**一些对象的共同特征**，但是具体这个杯子高十厘米，那个高五厘米……这些属性的**具体值**是属于**各个**杯子的，而不是“杯子”这个**类型**。
> 
> 从这个角度上，你也可以说，类型规定了对象**有什么**，却没具体规定对象**是什么**。就像 `int` 是数字**类型**，但 `int` **本身并不表示任何一个数字**（只告诉你 `a` 是个 `int`，你知道 `a` 是多少吗？），而是各个**类型为 `int` 的对象**（`3`、`5`、`1 + 2` 之类）表示各自的数字。

顺便提一句，虽然 `Cup` 类型**只有一个**，`height` 在 `Cup` 里面**也只有一个**，但这可不意味着所有杯子的高度都一样！在类里面定义的**属性**和**一般的变量**有些不同：当 Java 利用这个类型创建对象时，它会把 `height` 属性**复制**一下，让每个对象都有**专属的** `height` 属性。我们可以改变一个对象的属性，而完全不影响其它的对象 —— 大杯子和小杯子都是杯子，但它们并不是同一个杯子，不是吗？

---

你已经知道，如果给定**类型**，我们可以创建一个变量：

```java
String a = "Ciallo～(∠・ω< )⌒☆";
```

`Cup` 也是类型，所以我们也可以创建一个变量：

```java
Cup c = // ?
```

不过等一下，这里右边写什么呢？如果是数字，那我知道的呀，只要写出一个数字字面量（比如 `2`）就行了，但是我们自定义的类型，要怎么把它**创建**出来呢？

我们可以这么写：

```java
Cup c = new Cup();
```

`new` 可以基于类型**创建一个新的对象**。语法并不复杂：`new`，然后是**类型名**，后面加上一对小括号 `()`，看上去很像方法调用，不过这里请暂时还是把它记成固定格式吧。

现在我们有了一个类型是 `Cup` 的对象，并且我们把它用变量 `c` 来记录。这个新的对象还是**空的**，因为，**类型虽然规定了对象有什么，却没规定具体是什么** —— 这个新的对象，现在有 `height`、`radius`、`volume` 这几个**属性**，但它们的值却**还没有确定**。

所以现在，我们来设计杯子的高度、半径和体积：

```java
c.height = 10;
c.radius = 4;
c.volume = 3.14 * 4 * 4 * 10; // 体积公式
```

虽然这个表达看上去再自然不过了，但这里出现了我们先前提到的一个结构：**对象加上一个点** `c.`……这是什么意思？

**这个点 `.` 的意思，就是“的”。**`c.height` 就表示**对象 `c` 的 `height` 属性**，也就是所谓“杯子的高度”。当然了，虽然说是属性，但充其量也就是个变量，所以对它们的赋值，和一般的变量没有什么不同。

让我们再来多创建几个杯子：

```java
// 小杯子
Cup smallCup = new Cup();
smallCup.height = 5;
smallCup.radius = 2;
smallCup.volume = 3.14 * 2 * 2 * 5;

// 大杯子
Cup bigCup = new Cup();
bigCup.height = 15;
bigCup.radius = 6;
bigCup.volume = 3.14 * 6 * 6 * 15;

// 超级大的杯子
Cup giantCup = new Cup();
giantCup.height = 100;
giantCup.radius = 40;
giantCup.volume = 3.14 * 40 * 40 * 100;
```

忽略最后一个杯子可能太大了的事实，我们确实创建了三个杯子（有三个 `new`）。三个杯子有大有小，但它们都是杯子，因为它们都是 `Cup` 类型，并且拥有相同的属性 `height`、`radius` 和 `volume`。

?> 虽然这个例子中我们都是用的 `变量.属性` 这样的写法，但实际上点号前也可以是任意的表达式，只要它的类型是 `Cup`（或者你想用的其它类型）。

## 打包带走！

如果你仔细观察先前的例子，你会发现有这样三行：

```java
smallCup.volume = 3.14 * 2 * 2 * 5;
bigCup.volume = 3.14 * 6 * 6 * 15;
giantCup.volume = 3.14 * 40 * 40 * 100;
```

它们都是 `3.14` 乘上半径的平方，再乘高度。**仅仅是**半径和高度**不同**，我们就要**重新抄写**一遍这个公式 —— 我们以前是不是遇到过类似的情况？

比较熟悉**方法**的读者，应该可以很快写出下面的代码：

```java
// 计算体积的方法
double getVolume(double radius, double height) {
    return 3.14 * radius * radius * height;
}

// 使用这个方法来计算体积，就不需要背公式啦！
smallCup.volume = getVolume(smallCup.radius, smallCup.height);
bigCup.volume = getVolume(bigCup.radius, bigCup.height);
giantCup.volume = getVolume(giantCup.radius, giantCup.height);
```

`getVolume` 方法接受两个 `double` 类型的参数，一个是半径，一个是高度，然后用体积公式计算出体积（同样是 `double`），并返回回去。

我们已经说过，你可以把 `smallCup.volume` 这种对象的属性看成是**普通的变量**，所以，上面的代码其实也就不过是类似于这样的简单例子：

```java
double v = getVolume(r, h);
```

不过是把普通变量换成了对象的属性，可没什么难得倒你，对的吧？

---

好吧，也许不是，因为如果你仔细看一下后面三行：

```java
smallCup.volume = getVolume(smallCup.radius, smallCup.height);
```

这一行里面，`smallCup` 居然出现了**整整三次**！而且，这还不是唯一的问题，后三行里，**每一行我们都把变量名抄了三次**！

如果有 100 个杯子，我们就要把变量名总共写三百次！这个太吓人了，完全就是找虐。

同时，我们还发现了一件很重要的事情：

**不管是什么杯子，它的体积都可以用同一个公式计算出来。**

小杯子的体积是 `3.14` 乘半径的平方再乘高度，大杯子也是一样，即使是庞大无比，高度达到 `100` 的杯子，它也满足这个规律。这就说明，**“计算体积”这件事，是和具体的对象无关的**。只要是杯子，它就满足这个规律。

我们刚才是不是还说到过，**类型描述对象的共同特征**……？这么一看，“计算体积的方法”分明就是个“共同特征”，它也应该**能被类型描述**才对。能不能做到这一点呢？

答案当然是有的，而且做到这件事的，是一位老朋友 —— **方法**。啊啊，对不起，我本该在介绍到方法的时候就告诉你这件事，然而，那个时候就把类和对象的概念告诉你，可能就把你吓跑了。不过，现在也不算晚，请记住下面这句话：

**在 Java 中，所有的方法都是类型的一部分。**

> **到底怎么回事？**
> 
> 这里还是先给大家赔个不是，都是笔者不好。
> 
> 为了让代码尽可能简单一些，我们先前并没有使用完整的 Java 代码框架，而是简单地告诉读者，“你可以在这里写一个方法”。我们已经举过很多这样的例子：
> 
> ```java
> int add(int a, int b) {
>     return a + b;
> }
> ```
> 
> 然而，Java 中的方法**并不能**像上面这样，直接写在“白纸”上，**所有的方法都是类型的一部分**。换句话说，方法**不能凭空产生**，而必须“依附”在某个类型上，比如：
> 
> ```java
> class NumberAdder {
>     int add(int a, int b) {
>         return a + b;
>     }
> }
> ```
> 
> Java 的这个设计称不上是完美，即使是**完全不使用**类型和对象的概念，方法也必须定义在类型中，这不太合理，但毕竟是规范，所以还是希望读者能理解。从现在开始，我会尽可能规范地在类型中使用方法。

如果你对于 RPG 游戏比较熟悉的话，你就可以**把方法比作是技能**：技能会利用你的**属性**来**计算**伤害，你的属性越强，技能也就越强，而且就算有好几个人都有**一样的**技能，当你放技能的时候，系统还是会知道该用**你自己**的属性（而不是把小兵的属性套到你身上）。

在 Java 中，事情也是差不多的。类型中的方法，有这么几个特点：

- 可以**直接使用属性**，而不需要（也无法）加上对象的具体名字。属性**不需要**写在参数中，而可以看作是**预先定义好的变量**。

- 调用方法和使用属性一样，使用 `对象.方法(参数)` 的格式。方法会使用指定对象的属性完成计算。

所以现在，我们把 `getVolume` 放进 `Cup` 类型当中，就应该是这样：

```java
class Cup {
    double height;
    double radius;
    double volume;

    double getVolume() {
        return 3.14 * radius * radius * height;
    }
}
```

`getVolume` 现在没有任何参数，但我们还是可以使用 `height` 和 `radius`，这是因为 `getVolume` 方法现在和属性 `radius` 以及 `height` 都**一起**出现在 `Cup` 类型当中了，**方法可以利用属性**，既然“**已经是一家人了**”，不用见外也是可以理解的吧。

于是，现在如果我们想知道一个杯子的体积，就可以这么做：

```java
Cup cup = new Cup();
cup.height = 5;
cup.radius = 2; // 设定属性
double v = cup.getVolume(); // 这就 OK 了！
```

可以看到，`cup.getVolume()` 除了多了一个前缀，其实也和普通的方法**没有区别**，事实也确实如此，把它当作“能使用对象的属性”的方法就可以了，其它的（包括返回值、参数什么的）并无不同之处。

这里还有一件有趣的事情，如果你想了解，可以看看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 在我们以前见到的代码中，方法也可以使用它外面的变量，但这些变量都是**已经定义好的**。
> 
> 在类型当中，像是 `height` 这样的属性，在定义类型时**还不存在**，它只是个名字，却还没有对应的值。然而我们居然还是能在 `getVolume` 中使用它，为什么呢？
> 
> 当我们调用 `getVolume` 时，我们并不是“凭空”就能写出一句 `getVolume()` 的，**方法必须在对象上调用**，既然 `getVolume` 已经是类型的一部分了，我们就应该像上面的代码一样，使用 `对象.方法(参数)` 这样的写法（在这里是 `cup.getVolume()`）。而由于这个时候，对象**已经被创建出来了**（`cup`），那些属性都已经被填上了实际的值，而方法**总是在对象创建之后调用的**，因此尽管**设计**方法的时候这些属性还不存在，但**使用**的时候，这些属性的值早就准备好了。
> 
> 这同时也解释了下面这样的代码：
> 
> ```java
> Cup smallCup = new Cup();
> smallCup.radius = 2;
> smallCup.height = 5;
> double v1 = smallCup.getVolume(); // 62.8
> 
> Cup bigCup = new Cup();
> bigCup.radius = 6;
> bigCup.height = 15;
> double v2 = bigCup.getVolume(); // 1695.6
> ```
> 
> 你会发现，即使调用的都是**同一个**方法 `getVolume`，但结果却不一样。这是因为，当我们调用方法的时候，我们**指定了要使用的对象**。计算体积？计算谁的体积？计算**这个**杯子的体积。`smallCup.getVolume()` 使用 `smallCup` 的属性进行计算，而 `bigCup.getVolume()` 则使用 `bigCup` 的属性，使用的对象属性不同，结果当然就不一样。
> 
> 这同时也告诉我们，只要设置好对象的属性，之后**直接以 `对象.方法(参数)` 的格式调用方法**就行了，方法会**自动把当前对象的属性对号入座**。

当然了，这里没有使用参数**并不代表**方法变成类型的一部分后，就不能接受参数了，我们完全可以写：

```java
class Cup {
    double height;
    double radius;
    double volume;

    double getVolume(double pie) {
        return pie * radius * radius * height;
    }
}
```

这样就可以在调用 `getVolume` 的时候指定 π 的值了，可以粗略地采用 3，也可以精确到小数点后好多位。

> Kirara：如果我把参数的名字，写成和属性一样的呢？

那样的话，当你使用这个名字的时候，Java 就会**优先使用充当参数的变量**，而不是属性。其实并不难想：属性是在方法**外面**定义的，而参数则相当于是在方法**里面开头**定义的，按照我们在**块**那里已经了解的规则：在**方法内部定义的**同名变量，Java 会优先选择它。请看下面的代码：

```java
class Cup {
    double height;
    double radius;
    double volume;

    void myMethod(double height) {
        height = 2.0;
    }
}
```

```java
Cup c = new Cup();
c.height = 1.0;
c.myMethod(0);
double x = c.height; // 仍然是 1.0
```

尽管方法里面有一句 `height = 2.0`，看上去好像修改了属性，但由于**参数**里面也有一个叫做 `height` 的变量，Java 会把这个参数设置为 `2`（从而，**参数** `height` 一开始是 `0`，然后被改为 `2`），整个过程和第二行的**属性** `height` 没有任何关系。

!> 尽量避免把方法的参数和对象自身的属性写成同名的，像上面的例子，如果不仔细看，谁都会认为 `height` 指的就是属性，但实际上它是方法的一个参数。虽然这么写也不是说就罪大恶极，但为了不引起混乱，最好还是避免使用重复的名字。

## 与生俱来

我们再来看看先前的代码：

```java
class Cup {
    double height;
    double radius;
    double volume;

    double getVolume() {
        return 3.14 * radius * radius * height;
    }
}
```

```java
Cup smallCup = new Cup();
smallCup.height = 5;
smallCup.radius = 2;
smallCup.volume = 3.14 * 2 * 2 * 5;
```

当然，现在我们有了 `getVolume` 方法，我们可以让 `volume` 的计算变得简单些：

```java
smallCup.volume = smallCup.getVolume();
```

但是，上面的代码里，还是有一个漏洞。这个问题，由 Kirara 来为我们提出。

> Kirara：如果我忘记了要设置 `height` 和 `radius` 怎么办？

我们之前提到过，在定义类的时候，`height` 和 `radius` 都只是个**空壳** —— 它们一开始没有对应的值，它们的值是**在创建对象的时候被分别赋予各个对象的**。

如果我们不做这件事情，会怎么样？由于 Java 中**不存在“不存在”的东西**（这话有点拗口但确实是对的），Java 会为这些属性赋予一个默认的值。对于数字而言，这个值是 `0`，所以 `height`、`radius` 以及 `volume` 都会被设置为 `0`，直到我们修改它们。

这么做有没有道理呢？从 Java 的角度而言，这是为了避免错误，但从类型的角度而言，杯子的大小怎么可能是 `0` 呢？这显然不对。所以，这么做不太好。

有没有一种方法，可以让我们在对象**创建的时候**（而不是像现在这样在**创建完成之后**），就设置这些属性呢？答案是肯定的。请看下面的代码：

```java
class Cup {
    double height;
    double radius;
    double volume;

    Cup(double h, double r) {
        radius = r;
        height = h;
        volume = 3.14 * r * r * h;
    }
}
```

最显眼的莫过于 `Cup(double h, double r) { ... }` 了，这看上去**简直就是个方法**，除了没有返回值类型。除此之外，**这个方法的名字，和类的名字竟然完全相同！**

即使有点特殊，但和大家猜的一样，`Cup(double h, double r) { ... }` 确实就是一个方法，它是 `Cup` 类型的一个**构造方法（Constructor）**。构造，顾名思义，描述了如何从类制造出一个对象。

> **到底怎么回事？**
> 
> 类型就像是盖房子用的**蓝图**，它描述了一个房子应该是什么样，有几层，占地面积多少，等等。但是，类型本身并不是对象 —— 你不能住在一张蓝图里，想要把蓝图变成真正的房子，我们就需要**动手盖一栋**。在 Java 中，“依照蓝图盖房子”这件事，就是由**构造方法**完成的。
> 
> 我们前面已经提到过，Java 会把数字属性默认设置为 `0`。这其实是因为，在我们先前的 `Cup` 类型中，我们**没有指定构造方法**。就相当于我们不盖房子就想直接住进去 —— 当然不行！如果我们不亲自盖房子，Java 就会为我们盖一栋：**自动生成**一个构造方法，作用是把所有的属性设置为 `0`。问题在于，Java 不知道你想做什么，它**猜不出来**你是要做一个小杯子还是大杯子，所以这相当于，我们拿着一张摩天大厦的蓝图（定义好的类型），却由于没有技术高超的工程师（没有构造方法），最终只盖了个破茅草屋出来（属性不是我们想要的）。
> 
> 现在我们亲自接管这个过程，自行定义一个构造方法（请来我们的顶级工程师），来正确地创建对象。

一个类的**构造方法**用来制造一个对象，它有以下几个特征：

- 必须和 `new` 一起使用，来制造一个对象。

- 名称和类名相同。

- 不需要（也无法）使用对象名（因为这时候对象还没制造出来）。

- 可以在方法中自由使用各个属性，就像是已经定义好的变量一样。

- 可以接受参数，但没有返回值。

我们先把参数的部分去掉，如果没有参数，代码可能是这样的：

```java
class Cup {
    double height;
    double radius;
    double volume;

    Cup() {
        radius = 2.0;
        height = 5.0;
        volume = 3.14 * 2.0 * 2.0 * 5.0;
    }
}
```

构造方法 `Cup` **在对象创建的时候被调用**。它把属性 `radius`、`height` 和 `volume` 分别设置成我们指定的值。属性不能脱离对象存在，那么这些属性是哪个对象的属性呢？是**正在被创建的对象的属性**。请看下面的代码：

```java
Cup c = new Cup();
```

构造方法必须和 `new` 一起使用，所以构造方法 `Cup` 相当于把等号右边这个新创建出来的对象的半径、高度和体积分别设置为指定的值。**每次我们用 `new` 制造对象的时候，构造方法 `Cup` 都会工作一次，进行“出厂设置”**。

---

下面我们来把参数加回来：

```java
class Cup {
    double height;
    double radius;
    double volume;

    Cup(double h, double r) {
        radius = r;
        height = h;
        volume = 3.14 * r * r * h;
    }
}
```

参数是调用函数时提供的，什么时候 `Cup()` 会被调用呢？眼尖的读者应该已经发现了，使用 `new` 创建对象的时候，类名（同时也是构造方法名）后有一对小括号 `()`，是不是放在这里呢？确实如此：

```java
Cup c = new Cup(5, 2);
```

除了没有返回值（方法自身不提供，并且由 `new` 创建的新对象取代了），构造方法与一般的方法没有什么区别，因此参数的使用也是完全相同。

你会发现，使用带参数的构造方法来创建对象有一个优点：**创建对象时，我们只需要提供一部分的关键数据，由构造方法来完成更为具体的设定属性等操作**。这就像你用安装程序来安装软件，只需要点几下“下一步”，安装程序就会自动为你准备好软件。安装程序这个角色，就和构造方法的功能差不多。

---

现在我们就可以解答一开始提出的问题了：`s.equals("...")` 是什么？

- `equals` 是 `String` 类型的一个方法（字符串的类型是 `String`），它写出来大概是这样：
  
  ```java
  class String {
      // ...其它定义
      boolean equals(String another) {
          // 比较自身和 another 是否相等
      }
  }
  ```
  
  `equals` 方法**利用字符串自身的属性**（长度、第一个字符、第二个字符……），和参数上的另一个字符串**进行比较**，如果它们的内容相同，就返回 `true`，否则返回 `false`。

- **方法必须在对象上调用**，`equals` 的功能是“**把自身所属的字符串和提供的字符串进行比较**”，因此如果要比较 `s1` 和 `s2` 两个字符串，就写作：
  
  ```java
  if (s1.equals(s2)) {
      // 如果内容相等...
  }
  ```
  
  当然你在数学中已经学过，如果左边等于右边，那右边肯定等于左边，所以写成 `s2.equals(s1)` 也是一样的意思。

## Minecraft 中的对象

就以往的教学经验而言，读者往往很难理解“为什么要有对象”这个概念。看上去我们不过是把简单的内容复杂化了 —— 明明可以只写方法和变量，也可以做到很多事情。

我不打算在谈论什么封装之类的概念，我来给你提供一个更容易理解的答案：

**把与一个东西有关的数据和方法放在一起，只需要一个对象，就可以概括这个东西的全部信息。**

在 Minecraft 中，你曾经破坏过很多方块，如果我们想通过插件来破坏一个方块，你会怎么做？

如果没有对象的概念，我们就得提供**方块的坐标**，**方块的材质**（决定掉落物），然后再**使用一个方法**来破坏方块。就像：

```java
void breakBlock(int x, int y, int z, String material) {
    // 做点什么……
}
```

你会发现，参数中的 XYZ，方块的材质，还有破坏方块的方法本身，这些数据**明明都和方块有关，但是程序组织上竟然毫无关联**！

在实际的 Minecraft 中，一个方块类型有近 70 个公开方法（包括重载），内部的状态更是难以清点，如果不使用对象，是没有什么很好的办法，将这些数据联系起来的。我们将不得不在乱七八糟的方法大海中找到我们需要的那个方法，还有它用到的变量。

如果有了对象，我们要破坏一个方块，只需要设法**拿到代表这个方块的对象**，再**使用它的方法**就行了：

```java
Block block = world.getBlockAt(0, 0, 0); // 获得方块对象
block.breakNaturally(); // 把方块破坏掉
```

方法会**使用对象的属性数据**（或许还有其它的方法）来完成操作，这些属性（以及其它方法）是**跟着对象走**的，我们不再需要考虑数据怎么从一个方法传递到另一个方法，我们只需要考虑：**这个对象是什么，它有什么属性，它又能做什么（有什么方法）**。至于对象内部是怎么处理这些属性和方法的，在 `Block` （以及其它的）类型中早就定义好了，我们不用担心。

## 继续之前……

我原本打算把对象的内容在这一节就讲完的，不过这一节太长了，而且也没有什么有趣故事，加上对象本身是一个不容易理解的概念，因此我们在这里停一下，稍事休息，再进入我们的最后一节。

如果你对于对象和类的理解比较困难，或者不够清晰，下面的资料也会很有帮助：

- [Java 对象和类](https://www.runoob.com/java/java-object-classes.html)，菜鸟教程出品，即使你没有读他们的 Java 教程，我也非常建议你读读“对象和类”这一节。

- [Classes and Objects in Java](https://www.geeksforgeeks.org/classes-objects-java/)，GeeksforGeeks 的教程，作为英文教程，更贴近“对象和类”本来的意思，如果英文水平不错，也建议你读一读。
