# JA-5 Java 接口

## 一个钻石引发的惨案

你已经知道，类可以通过继承来“获取”另一个类的内容：

```java
class CowPower {
    void moo() {
        // moo
    }
}

class SuperCowPower extends CowPower {
    void moomoo() {
        // moo moo
    }

    // 从基类 CowPower 中获得了 moo 方法 
}
```

在一些面向对象的语言中，一个类可以直接继承多个基类：

```java
class Super1 {}
class Super2 {}
class Derived extends Super1, Super2 {}
```

这种模式被称为**多重继承（Multi Inheritance）**，指代的就是这种**一个类继承多个基类**的结构。在这个例子中，`Derived` 就同时获得了 `Super1` 和 `Super2` 的内容。是不是很方便？只要把想要的东西统统写在 `extends` 之后，就可以随意使用啦！

事实上也确实如此，这种模式（称为**多重继承**）的方便性使之被大量的软件工程师使用。然而，多重继承有一个致命的缺陷，请看下面的例子。

```java
class A {
    void foo() {
        // 要做之事……
    }
}

class B1 extends A {}
class B2 extends A {}

class C extends B1, B2 {}
```

`B1` 和 `B2` 都从 `A` 中继承 `foo` 方法，然后 `C` 又从 `B1` 和 `B2` 中各继承它们的 `foo` 方法。这就引发了一个问题：如果要调用 `C` 的 `foo` 方法，**实际被调用的到底是哪个方法？**

也许你会说，这里只有一个方法，那肯定就是 `A` 中定义的 `foo` 嘛！那么，假如 `B1` 又重写了 `foo` 方法，`C` 应该调用哪个 `foo`？或者更糟，`B2` 也重写了 `foo` 方法，这个问题还能解决吗？

—— Maybe。

这个问题，被称为**钻石难题（Diamond Problem）**，并非凭空而来，而是在 C++ 中真实存在的。为了修补这个漏洞，无数 C++ 工程师和面向对象工程师，还有大量的程序设计人员，付出了许多努力，通过虚继承等一系列手段，勉强解决了这个问题 —— 的一部分。然而，且不论这些手段是否从根本上解决了多重继承带来的问题，它们在 C++ 本就复杂的语言系统上拆东补西，弄得晦涩难懂，失去了面向对象本身的简洁性。

## 苦痛的快乐

在 Java 中，钻石难题的解决则非常简单，或者说，非常暴力：

**Java 禁止多重继承，一个类只能拥有一个直接基类。**

这种 Kirara 式的处理方案 —— 哎哟，不要打我！好吧，这种处理方案，虽然有些“因噎废食”的嫌疑，但实践证明，它在使面向对象机制简洁且可靠方面，**确实很有效**。

多重继承虽然（在 Java 中）失败了，可工程师们并不愿意放弃多重继承本身的便利性。如果被正确地使用，多重继承将是非常便捷的。举一个最简单的例子，假设你是 Mojang 的工程师，现在正在编写 Minecraft 的物品系统。你已经设计了 `Item` 类用来代表一般的物品：

```java
class Item {
    void getName() {
        // 获取物品的名称
    }

    // 其它有用的方法
}
```

现在你打算把 `Sword` 类（剑）和 `Axe` 类（斧）加入到游戏中。自然，作为工具，这两类物品除了有名字，当然还有耐久度，于是你写出这样的代码：

```java
class Item {
    void getName() {
        // 获取物品的名称
    }

    // 其它有用的方法
}

class Sword extends Item {
    int getDurability() {
        // 获取耐久度
    }

    void breakCobweb() {
        // 摧毁蜘蛛网
    }

    // 其它有用的方法
}

class Axe extends Item {
    int getDurability() {
        // 获取耐久度
    }

    void breakLog() {
        // 摧毁原木方块
    }

    // 其它有用的方法
}
```

你就会发现，我们又开始做**复制粘贴**的工作了 —— `getDurability` 方法在 `Sword` 类和 `Axe` 类中都出现了一遍。也许你会想将 `getDurability` 移动到 `Item` 中，然而问题是，并非每个物品都有耐久度。

> Saki：我认为即使允许少量的代码重复，也不会构成太大的问题？

抛开工程师们一般都喜欢偷懒的问题不谈，如果只是复制粘贴就能解决问题，那么事情还没那么糟糕。现在，请设想你在编写插件，你已经检测到玩家使用了一件物品，要减少它的耐久度。

```java
void decreaseItemDurability(??? i) {
    // 要做之事……
}
```

`???` 处将没有办法填入任何一个类型 —— `getDurability` 方法独立地存在于每个拥有耐久的类上（`Sword`、`Axe`、`Helmet` 等）。尽管我们已经知道这些方法做的都是同一件事情，却**缺乏一种方式来描述这一共通性**！

在不引入多重继承的情况下，能不能解决这个问题呢？

—— Maybe。

我们可以创建一个中间类 `DurableItem` 代表“有耐久的物品”，并让 `Sword` 和 `Axe` 继承它，其余没有耐久的物品则直接继承 `Item`。这看上去似乎就解决了问题，不是吗？

这个方案在系统中的类**很少**的时候还可以奏效，然而，在实际的 Minecraft 中，有某些物品有耐久，有某些物品有附魔列表，有某些物品有药水效果，有某些物品有特殊的动画……这是都是物品可能具有或不具有的**特征**。如果要以中间类的方式描述共通性，我们就必须**为每种可能的组合编写一个类**，甚至可能更多。

这样的组合到底有多少呢？由于每个特征都可以存在或不存在于某个物品之上，除去空白的 `Item` 类以外，有 2 的 N - 1 次方种可能，其中 N 是特征的个数。这意味着，即使是我们上面已经列出的四个特征，也会产生十五个中间类。如果特征的数目继续增加，按照指数增长的规律，我们有用的代码很快就会被淹没在茫茫无尽的中间类大海中。

这一切都是因为**没有多重继承**，如果有多重继承，我们就能**挑选需要的特性**，加入到我们的类中了。

?> 反过来说，类是用来描述对象特征的，它原本也就应该具有自由组合的能力。否则，面向对象本身也就失去了意义。

## 最终方案

有多重继承会有钻石难题，没有多重继承会有中间类难题。Java 工程师们掉了大把的头发，最终踢出了一个差强人意的解决方案。

我们知道，钻石难题的根本原因是**被继承的类对于同一个方法有不同的行为**，从而导致了**继承冲突**。那么，假如我们只允许方法有名字（和参数列表），却**不允许它有实质性的行为**，是不是就在不丢弃多重继承的前提下，解决了钻石难题呢？

答案是肯定的，这就是**接口（Interface）**。

在 Java 中，接口是一种特殊的类，写出来就像这样：

```java
interface Durable {
    int getDurability();
}
```

你会发现，接口和类很像，除了以下几点区别：

- 接口使用 `interface` 来定义，一般的类则使用 `class` 来定义。

- 接口中尽管有方法，但这些方法都**没有方法体** —— 参数列表的小括号 `()` 后面缺少了属于它的大括号 `{}`。
  
  ?> 在 Java 中，没有方法体的方法被称作**抽象方法（Abstract Method）**，也称**虚方法（Virtual Method）**。
  
  !> 请注意，**没有方法体**（缺少大括号 `{}`）和**方法体为空**（尽管有大括号 `{}` 里面却没有内容）是两种**完全不同**的东西。前者代表“还不确定要做之事是什么”，而后者代表“要做之事？就是什么也不做！”。

- 接口不能使用 `new` 来创建它的对象。

简而言之（不太准确地），接口就是**只包含抽象方法的类**。

既然方法体都没有，那么接口有什么用呢？我们总不能直接去调用这些方法吧？的确不能，因为抽象方法“不确定要做什么”，你无法直接调用一个还不知道该做什么的方法。

要使用接口，我们需要**创建一些类**来“继承”它。在术语中，“继承”接口被称为**实现（Implement）**。虽然换了一个词，不过也就和继承是差不多的意思。

```java
interface Durable {
    int getDurability();
}

class Sword implements Durable {
    @Override
    int getDurability() {
        // 要做之事……
    }
}
```

我们只是把原来那个位置上的 `extends` 换成了 `implements`，其它的都和继承完全相同。这样，`Sword` 就从 `Durable` 那里继承来一个方法 `getDurability`，只不过，这个方法有些特殊，它是个抽象方法。

> Kirara：继承来一个什么也没有的方法有什么用？

问出来这个问题，至少证明你已经开始像 Java 程序员一样思考了（笑）。下面是一个解释：

> **到底怎么回事？**
> 
> 以往我们使用继承，都是出于偷懒的目的：“相同的代码不用再写一遍，只要从那个类搬过来就行啦”，这也是继承最原始的用途。
> 
> 然而，继承的含义不仅如此。在 Java 中，继承在享受基类提供的便利的同时，还必须要**担负相应的责任**。具体来说，派生类可以获得基类中已经写好的代码，但同时**也需要“填实”基类中还未完成的方法**。
> 
> 从这个角度上来看的话，接口确实是个不怎么称职的父亲，把一大堆烂摊子（抽象方法）全甩给了派生类（笑）。不过接口存在的意义可不只是甩锅而已，稍后我们会从程序设计的角度，介绍接口的重要意义。

既然 `Sword` 已经接手了 `Durable` 接口的“烂摊子”，它就要把这些烂摊子解决掉。解决方法很简单，就是**重写**。相信通过 [1-2](1-2) 中的代码，你已经对此不陌生了：**定义一个同名同参数的方法，再添加上一个 `@Override` 注解**，就是这么简单。

现在我们用接口 `Durable` 和基类 `Item`，重新编写我们的物品系统：

```java
class Item {
    void getName() {
        // 获取物品的名称
    }

    // 其它有用的方法
}

interface Durable {
    int getDurability();
}

class Sword extends Item implements Durable {
    @Override
    int getDurability() {
        // 获取耐久度
    }

    void breakCobweb() {
        // 摧毁蜘蛛网
    }

    // 其它有用的方法
}

class Axe extends Item {
    @Override
    int getDurability() {
        // 获取耐久度
    }

    void breakLog() {
        // 摧毁原木方块
    }

    // 其它有用的方法
}
```

注意到同时有类继承和接口实现时，`implements` 写在 `extends` 的后面。

尽管我们还是不得不在 `Sword` 和 `Axe` 中分别编写 `getDurability` 方法（用来“填实”`Durable` 中尚未实现的方法），但好消息是，`Durable` 接口现在就能用来描述“具有耐久度”这个**共通特征**了。先前留下的问题，也在此得到了解决：

```java
void decreaseItemDurability(Durable i) {
    int dur = i.getDurability();
    // 更多要做之事……
}

decreaseItemDurability(new Sword())
decreaseItemDurability(new Axe())
```

我们先前已经说过，派生类的对象**可以当作一个基类的对象来使用**，这一点对于接口也是适用的：`Sword` 类实现了 `Durable` 接口，所以 `Sword` **是一种** `Durable`，因而我们可以直接将 `Sword` 用作 `decreaseItemDurability` 的参数。

更美妙的事情是，在未来，如果有一种新的物品出现了，它同样具有耐久度，那么我们将**完全不需要修改现有的代码**！只需要在新物品的类中，同样实现 `Durable` 接口，新物品就同样可以用在这个方法当中，一切就 OK 啦！

> Kirara：我还是不能理解，`i` 不是一个类型为 `Durable` 的变量吗？`Durable` 中的方法不是空的吗？

如果读者也像 Kirara 一样对这一点感到困惑，请看下面的“到底怎么回事”。

> **到底怎么回事？**
> 
> 先前已经提到过，Java 在调用变量的方法时，总是调用它**实际类型**中定义的方法。如果 `i` 的实际类型是 `Sword`，它就调用 `Sword` 中定义的 `getDurability` 方法。类似地，如果 `i` 的实际类型是 `Axe`，它就调用 `Axe` 中定义的 `getDurability` 方法。我们不需要关心 `i` 的具体类型，只需要知道 Java 总会通过多态调用到正确的方法 —— 如果是剑，就用剑的方法处理，如果是斧，就用斧的方法处理。
> 
> 现在关键的问题是，`i` 的**实际类型**会不会是 `Durable`？如果是的话，尽管 `Durable` 中有 `getDurability` 方法，但它是抽象的，不能直接调用。
> 
> 答案是**不会**。因为 Java 中**不存在真正不存在的东西**。
> 
> 尽管 `Durable` 中有未实现的方法，但由于无法用 `new Durable()` 这样的方式来创建其对象，所以在 Java 中，其实并没有哪一个对象的实际类型，真的是 `Durable`。换而言之，这个参数 `i`，必定是由某个**已经实现了 `Durable` 的类**转换而来的，后者必定已经填实了 `getDurability` 方法。

顺便一提，不像 `extends` 只能继承一个类，`implements` 可以实现多个接口，只需要用逗号 `,` 将它们分隔开：

```java
interface A {
    void foo();
}

interface B {
    void bar();
}

class C implements A, B {
    @Override
    void foo() {
        // 要做之事……
    }

    @Override
    void bar() {
        // 要做之事……
    }
}
```

当然，实现多个接口的类需要**重载每个接口中的抽象方法**，不然就乱套了。

## 最终方案的后日谈

接口的出现解决了钻石难题，很大程度上也解决了特征组合的问题。或许读者对于接口的设计和实际意义还有些疑问，那么，我们再讲一个故事。

> **广募贤才**
> 
> 灾难发生后，重建过去生活的城市是一件迫在眉睫的工作。光点郡郡主派遣了猎头小队，在全岛范围内寻找有能之人。需求最多的是建筑工程师和材料学家，此外还有大量的设计师、炼金术师、试验工程师以及管理团队。郡主开出的酬谢属实不菲：二百六十七万银币！这是一般的贵族终其一生也未必能获得的财产。而要拿到这笔巨款的条件却异常简单：**能胜任招募单上的需求**。
> 
> 如果说我曾经是猎头小队中的一员，大家会不会相信呢？暂且先当是如此吧。猎头小队的人也眼红这么多的银币，但可惜在他们**没一个人**有把握说，“交给我盖的房子，一百年也不会塌”。既然没能力胜任，那自然也就不敢毛遂自荐了。
> 
> —— 我能受这委屈吗？我刚学的炼金术。尽管只是入门水平，不过看郡主的要求，似乎只要能够把彩色石英转换成透明水晶就够了。内行人都知道，这只不过是最基础的知识之一。既然**能满足需求**，为什么不试试？我立即填写了申请表。
> 
> 一个月后，郡主拿到了志愿者的名单，看到了一个熟悉的名字，她很吃惊，“怎么是你？”她半信半疑地看着我将石英原液在空中凝成了一个堪称完美的水晶球。
> 
> 哈，其实她的参谋一直都会炼金，只是她总是当我只会笔头工作而已。

如果说类从**完整的角度**描述了一个对象的**具体信息**，那么接口就相对应地，从**抽象的角度**描述对象的**某一部分信息**。比方说，类会考虑一个人的姓名、年龄、适合的工作种类等，而“建筑师”接口只考虑“是否会盖房子”这一个问题。一个类可以同时**实现多个接口**，代表它**同时具有多方面的“能力”**。相对应的，当我们**需要具备某个“能力”的类**时，只需要**指定对应的接口**进行“招募”，那么所有实现了这个接口的类，都可以来“应聘”。

以下是图解：

![.](https://imgos.cn/2024/08/10/66b70c9bd9d89.png)

招募协议规定了应聘者应该有的能力，但**招募协议本身什么也不做** —— 你不能让一张纸来帮你炼金！我们使用接口，就是**指定了我们需要什么能力**，而这些能力**具体如何使用**，是由**各个实际的类**来完成的。当然，相对应的，如果一个类想让自己能成为“多面手”，它就要“训练”自身来**实现更多的接口**，这样它就能胜任更多的工作。

接口这一概念，不仅是 Java 语言的一个特性，更是一种编程哲学。程序通常是由**多个部分**构成的，使用接口的思想，每个部分只需要**独立地考虑**“我**能做**什么”和“我**需要**什么”，而**无需考虑其它部分的具体细节**，这能为我们节省不少的脑细胞消耗呢（笑）。

“纸上得来终觉浅，绝知此事要躬行。”文字的描述总是枯燥而肤浅的，在后续的项目中，我们会经常使用到接口，届时读者将对接口的作用有进一步的了解。
