# MC-1 游戏背后的故事

相信各位读者都是 Minecraft 的资深玩家，在不同的生物群系中探索各式各样的地形，建造红石电路来驱动强大的机械装置，或者制作一张巨大的像素画，对各位来说应该都不是难事。

游戏当中的内容很丰富，但是，在这些**游戏元素**的背后，潜藏着更多的**技术性信息**。它们或许不如游戏那样有趣或者直白，但是当你随口说出“请把箱子放在这个区块的正中心”这种话时，旁人一定觉得你帅呆了（或者疯了，因为区块是 16×16 大小的，没有正中心）。

## 全球定位系统

老玩家对于坐标肯定不陌生，坐标可以指代世界当中的**一个位置**。坐标由 X、Y、Z 三个轴方向上的距离组成，其中 X 和 Z 是“躺在地上的”，称作**横轴**，也叫做**平面位置**，而 Y 是“立起来的”，称作**纵轴**，也叫做**高度**。

坐标可以**唯一地**确定某个位置，反过来，世界当中的每个方块和实体，也都有**唯一的坐标**。不论是在出生点附近还是远在世界边界，乃至主世界基岩下方的虚空中，只要给出对应的坐标，就能找到这些位置。

因此，如果我们在做插件时想要指代世界当中的某个位置，我们不用截图或者给人比划“在这里在那里”，只需要给出三个数字就可以了（比如 `0 128 0`）。

方块的坐标通常是整数，而实体因为可以移动，坐标通常是小数。在 Java 中，Mojang 统一使用 `double` 类型来存储坐标的三个数字。

## 它们不是空的

下面是一个有趣的事实：

**每个有效坐标对应的位置都有一个方块，而且只能有一个方块。**

有效坐标是指在世界边界以内，并且高度在世界底层（主世界 -64，下界和末地 0）至建筑高度限制（主世界 319，下界和末地 256）这样一个“盒子”之内的坐标。

那有人就要问了，这海平面上不是什么都没有吗？哪里有方块？

实际上，那些地方并不是没有方块 —— 它们是**空气方块**。这可不是我嘴硬，这些方块的材质在 Minecraft 中确实就是空气（`minecraft:air`）。

所以，我们可以说，**给出一个坐标，就能找到它唯一对应的一个方块**。也就是说，“放置方块”其实不是让方块无中生有，只是**把空气方块换成了玩家手中的方块**。同理，挖掘方块也不是让方块就此消失，而是**把被破坏的方块换成一个空气方块**。

## 注册名称

每一种方块都有其独特的**材质（Material）**。注意这里所说的材质和“材质包”并不是一个意思：后者是一系列图片，指的是方块的外观和颜色，也叫做**纹理（Texture）**；而我们所说的材质，指的是方块**本来是什么**，例如工作台、樱花原木、黑曜石等。

我们常说的“草方块”，实际上是这个方块的**译名（Translated Name）**，在不同的语言中，翻译也不尽相同。尽管在中文社区中交流很顺利，但如果放到程序里面，就显得不太合理了。

这种情况下，在游戏内部，就有必要用一个“众所周知”的名字来指代“草方块”这个东西，这就是**注册名称（Namespaced Key）**。

在 1.12 及更早的版本中，游戏内部是用一个数字 ID 来代表各个方块（和物品）的，例如草方块的 ID 是 2，而黑曜石是 49。在 1.13，Mojang 对游戏做了一些更改，其中之一就是**方块的数字 ID 改用注册名称来表示**。草方块因此成为 `grass_block`，黑曜石则是 `obsidian`，以此类推。

?> 你可以在 [Minecraft Wiki](https://zh.minecraft.wiki) 上查找到每个方块的注册名称。顺便说一句，Wiki 现在已经迁移到了新的网站，因此就不要再用又老又慢的 Fandom 啦！

这个设计看上去很好，但仅限于原版游戏。如果加入了一些 Mod，很快就会产生一个新的问题：**名称冲突**。例如，1.17 加入了铜锭，名为 `copper_ingot`，倘若有个模组也添加了铜锭，而且名字还相同，游戏就分不清楚谁是谁了。

可是，这种现象发生过吗？没有，这是因为注册名称除了有代表具体材质的**注册键（Key）**，还有一个**命名空间（Namespace）**。草方块的完整注册名称是 `minecraft:grass_block`，黑曜石是 `minecraft:obsidian`。就像 Java 中的包一样，命名空间加在注册键的前面，把各个键**分门别类地收集管理**。

如果一个服务器上没有任何模组，那么原则上所有的方块和物品都属于 `minecraft` 这个“组”（命名空间）。但是，我们的插件偶尔也会安装在模组服务器上，**模组会添加自己的命名空间**，这时候就要考虑类似 `twilight_forest:blahblah_log` 这种**属于某些其它命名空间**的注册名称。

?> 你可以把注册名称类比于电子邮件地址，就像是 `grass_block@minecraft` 以及 `blahblah_log@twilight_forest` 一样，是不是就好理解多了？嘛，只不过 Minecraft 中命名空间在前而已。

## 滴答，滴答

Minecraft（以及其它绝大多数游戏）每秒钟都要做很多事情。游戏不停地检测玩家的输入（按下键盘，移动鼠标等）并**计算和刷新**游戏内的各种状态（生物移动，昼夜更替，作物生长等）。Minecraft **循环不断地**做这些检查和处理，每秒钟要执行 20 次。

你可以把这个过程想象为生活中的一天。我不太确定读者每一天的安排 —— 那毕竟是个人隐私。不过 Kirara 在樱云的一天，一般是早起，上午学习魔学，中午在学院研究矿石材料，下午和晚上则用来创作。

每天的日程都基本相同 —— 不断**重复执行**一些固定的工作。对于人类而言，这每一次循环叫做一天，不过对于游戏，我们有一个更加专业的说法：**刻（Tick）**。

Minecraft 每秒执行 20 刻，在每一刻中都对游戏的状态**进行一次完整的计算和刷新**，这样玩家的操作能够及时在屏幕上得到响应，而不至于右键按了半天，方块才放下来。

用代码来描述的话大致是这样：

```java
while (gameIsRunning) {
    doThis();
    doThat();
    doBlahBlah();
    // 更多其它的处理
}
```

这个循环当中的内容，实际上就**构成了游戏的全部机制**。昼夜更替 —— 每刻计算新时间并改变天空的颜色；生物移动 —— 每刻执行生物 AI 并计算生物的新位置；破坏和放置方块 —— 每刻检测玩家的输入，并改变方块的状态。

?> 实际上还有少部分机制不在游戏刻中执行，比如自动保存。不过，可以粗略认为，**游戏内容**中的所有机制都是在游戏刻中执行的。

## 有条不紊

既然游戏的全部机制都在一个刻中实现，那么如果我们想修改游戏的某一部分，要怎么做呢？

最简单粗暴的方法就是直接修改 Minecraft 的代码：

```java
while (gameIsRunning) {
    doThis();

    doAnotherThing(); // 加入我们想做的事情

    doThat();
    doBlahBlah();
    // 更多其它的处理
}
```

*（这不是实际的代码，只是举个例子，便于读者理解。）*

这么做很粗暴，很麻烦（需要设法获得 Minecraft 的源代码），而且用这种方法做出来的东西，**兼容性很差**：如果两个插件都修改了游戏的同一个地方，那到底该听谁的啊？这样游戏就会变得非常混乱。

Bukkit 设计出来就是解决这个问题的。当我们使用 Bukkit 提供的 API 的时候，我们不需要亲自修改 Minecraft 的代码，而是**向 Bukkit 告知**我们想做什么，由 Bukkit 为我们**统一安排**代码的执行。

## 事件

我们要如何告知 Bukkit 我们想做什么呢？当然不是把我们的代码打个包直接喂进去，那样 Bukkit 就没有什么存在感了，还不如我们自己来修改呢。

刚才我们已经讲到过，游戏会以每秒 20 次的频率重复地做一些事情。

这个速度很快，但大多数时候，我们的插件并不需要持续不停地检查、检查、检查……我们**只关注某些特定的事情发生的时刻**（例如：玩家放置了一个方块，一个苦力怕爆炸了，时间刚刚从白天切换到夜晚）。

这些被我们所关注的事情，就叫做**事件（Event）**。

事件是当游戏**到达某个特定的状态**时，由 Bukkit 为我们发送的一个**通知**。就像电子邮箱客户端收到邮件时的通知一样：我们不需要每分钟都去翻一下收件箱，当有邮件来的时候，程序会告知我们的。

Bukkit 插件的基本工作方式就是：**当特定的事件发生时，执行一些操作。**

图解如下：

![.](https://imgos.cn/2024/08/10/66b70cc563aa1.png)

当然，即使是图解也不是那么直观，我们来举个具体的例子。

大家一定都见过那种欢迎玩家的消息：“欢迎 XXX 来到服务器”。像这样的插件，工作原理大致是这样的：

1. 插件告诉 Bukkit：**我对“玩家加入游戏”这件事很感兴趣**，请帮我注意一下！
   
   插件把任务告诉了 Bukkit 这个“哨兵”之后，自己就回去睡大觉了，Bukkit（和 Minecraft）则一边继续处理游戏事务，一边时刻注意着有没有玩家加入游戏。
   
   只要 Bukkit 不去告诉插件，插件就什么也不做，它会等待“玩家加入游戏”这件事的发生，这叫做**侦听事件（Listening）**。顾名思义，插件静静聆听着周围的动静，直到感兴趣的事到来。

2. 某个时刻，也许是几秒钟之后，也许过了成百上千年，有一个玩家加入了服务器。
   
   Bukkit 立刻发现了这一点，它拿过一张纸（当然不是真的纸），在上面迅速地写下**事件的详细信息（Details）**，例如玩家名，时间，IP……只要是它觉得有用的信息，它就都写上去。
   
   在 Java 中，一切都是对象，而事件本身也不例外。事件的详细信息随事件对象一起被创建，这叫做**事件触发（Triggered）**。

3. Bukkit 找到它所有的“委托人”，当然也包括我们的插件，然后敲响他们的门铃，“喂，有玩家来了！”，并同时把事件的信息传递给委托人。
   
   Bukkit 把刚刚发生的事件，通知给每一个正在侦听事件的插件，这叫做**广播（Broadcast）**。和现实生活中的广播是一个意思啊，“各位旅客请注意，D1145 次列车开始检票”这样的广播，会通知到每一个等车的乘客。

4. 插件收到信号，就开始它的工作。在我们的例子里，它给所有玩家发送一条消息，“欢迎 XXX 加入服务器！”，并把 XXX 换成收到的玩家名。
   
   这个接受事件并对其做出反应的过程，就叫做**事件处理（Process）**，偶尔也称**事件响应（Respond）**。

5. Bukkit 继续处理游戏事务，同时观察着是否有玩家加入服务器……

以上就是大致的工作流程。从中我们可以发现，设计插件时，我们只要考虑两件事情：

- 我们的插件该**关心什么事情**。登录插件要关注玩家加入服务器，领地插件则可能要关注玩家破坏和放置方块，传送插件则关注玩家所输入的命令……
  
  插件可以侦听一个事件，也可以侦听许多许多事件，这完全是按照插件所需的功能决定的。

- 当这个事件发生时，我们的插件要**做什么**。登录插件在玩家加入时提示他们登录，诸如此类。

这种结构被称为**事件驱动（Event Driven）**，用来编写插件非常方便：我们不再需要关注游戏里诸多的细节，不需要考虑 Minecraft 的源代码长什么样，也不需要关心其它的插件在做什么，我们只需要**侦听事件**，并在事件触发时**处理事件**就可以啦。

> Kirara：在我们的第一个插件里，我们关注了什么事件呢？

如果你仔细查看 HellWorld 项目的代码：

```java
public void onEnable() {
   // ...
}
```

方法的名字翻译过来就是“在启用时”，也就是说，我们**关注的是“插件被启用”这个事件**。

实际上啊，我们之前说“插件从 `onEnable` 开始执行”这句话并不太严谨。我们的插件**仅仅是侦听了“启用”这个事件**，然后**在收到这个事件的时候开始做准备工作**而已。

如果所有的事件都像 `onEnable` 这样可以通过在主类中定义方法来侦听，那可就太好了。遗憾的是，由于 Minecraft 中的事件实在有太多太多，通过向主类添加方法来定义它们是不现实的。对于一般的事件，Bukkit 使用了一套特殊的机制来让插件侦听它们，我们将在下一节介绍。
